{"ast":null,"code":"/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\nvar events = require('events'),\n    util = require('util'),\n    crypto = require('crypto'),\n    EventEmitter = events.EventEmitter,\n    ErrorCodes = require('./ErrorCodes'),\n    bufferUtil = require('./BufferUtil'),\n    PerMessageDeflate = require('./PerMessageDeflate');\n/**\n * HyBi Sender implementation\n */\n\n\nfunction Sender(socket, extensions) {\n  if (this instanceof Sender === false) {\n    throw new TypeError(\"Classes can't be function-called\");\n  }\n\n  events.EventEmitter.call(this);\n  this._socket = socket;\n  this.extensions = extensions || {};\n  this.firstFragment = true;\n  this.compress = false;\n  this.messageHandlers = [];\n  this.processing = false;\n}\n/**\n * Inherits from EventEmitter.\n */\n\n\nutil.inherits(Sender, events.EventEmitter);\n/**\n * Sends a close instruction to the remote party.\n *\n * @api public\n */\n\nSender.prototype.close = function (code, data, mask, cb) {\n  if (typeof code !== 'undefined') {\n    if (typeof code !== 'number' || !ErrorCodes.isValidErrorCode(code)) throw new Error('first argument must be a valid error code number');\n  }\n\n  code = code || 1000;\n  var dataBuffer = new Buffer(2 + (data ? Buffer.byteLength(data) : 0));\n  writeUInt16BE.call(dataBuffer, code, 0);\n  if (dataBuffer.length > 2) dataBuffer.write(data, 2);\n  var self = this;\n  this.messageHandlers.push(function () {\n    self.frameAndSend(0x8, dataBuffer, true, mask);\n    if (typeof cb == 'function') cb();\n  });\n  this.flush();\n};\n/**\n * Sends a ping message to the remote party.\n *\n * @api public\n */\n\n\nSender.prototype.ping = function (data, options) {\n  var mask = options && options.mask;\n  var self = this;\n  this.messageHandlers.push(function () {\n    self.frameAndSend(0x9, data || '', true, mask);\n  });\n  this.flush();\n};\n/**\n * Sends a pong message to the remote party.\n *\n * @api public\n */\n\n\nSender.prototype.pong = function (data, options) {\n  var mask = options && options.mask;\n  var self = this;\n  this.messageHandlers.push(function () {\n    self.frameAndSend(0xa, data || '', true, mask);\n  });\n  this.flush();\n};\n/**\n * Sends text or binary data to the remote party.\n *\n * @api public\n */\n\n\nSender.prototype.send = function (data, options, cb) {\n  var finalFragment = options && options.fin === false ? false : true;\n  var mask = options && options.mask;\n  var compress = options && options.compress;\n  var opcode = options && options.binary ? 2 : 1;\n\n  if (this.firstFragment === false) {\n    opcode = 0;\n    compress = false;\n  } else {\n    this.firstFragment = false;\n    this.compress = compress;\n  }\n\n  if (finalFragment) this.firstFragment = true;\n  var compressFragment = this.compress;\n  var self = this;\n  this.messageHandlers.push(function () {\n    if (!data || !compressFragment) {\n      self.frameAndSend(opcode, data, finalFragment, mask, compress, cb);\n      return;\n    }\n\n    self.processing = true;\n    self.applyExtensions(data, finalFragment, compressFragment, function (err, data) {\n      if (err) {\n        if (typeof cb == 'function') cb(err);else self.emit('error', err);\n        return;\n      }\n\n      self.frameAndSend(opcode, data, finalFragment, mask, compress, cb);\n      self.processing = false;\n      self.flush();\n    });\n  });\n  this.flush();\n};\n/**\n * Frames and sends a piece of data according to the HyBi WebSocket protocol.\n *\n * @api private\n */\n\n\nSender.prototype.frameAndSend = function (opcode, data, finalFragment, maskData, compressed, cb) {\n  var canModifyData = false;\n\n  if (!data) {\n    try {\n      this._socket.write(new Buffer([opcode | (finalFragment ? 0x80 : 0), 0 | (maskData ? 0x80 : 0)].concat(maskData ? [0, 0, 0, 0] : [])), 'binary', cb);\n    } catch (e) {\n      if (typeof cb == 'function') cb(e);else this.emit('error', e);\n    }\n\n    return;\n  }\n\n  if (!Buffer.isBuffer(data)) {\n    canModifyData = true;\n\n    if (data && (typeof data.byteLength !== 'undefined' || typeof data.buffer !== 'undefined')) {\n      data = getArrayBuffer(data);\n    } else {\n      //\n      // If people want to send a number, this would allocate the number in\n      // bytes as memory size instead of storing the number as buffer value. So\n      // we need to transform it to string in order to prevent possible\n      // vulnerabilities / memory attacks.\n      //\n      if (typeof data === 'number') data = data.toString();\n      data = new Buffer(data);\n    }\n  }\n\n  var dataLength = data.length,\n      dataOffset = maskData ? 6 : 2,\n      secondByte = dataLength;\n\n  if (dataLength >= 65536) {\n    dataOffset += 8;\n    secondByte = 127;\n  } else if (dataLength > 125) {\n    dataOffset += 2;\n    secondByte = 126;\n  }\n\n  var mergeBuffers = dataLength < 32768 || maskData && !canModifyData;\n  var totalLength = mergeBuffers ? dataLength + dataOffset : dataOffset;\n  var outputBuffer = new Buffer(totalLength);\n  outputBuffer[0] = finalFragment ? opcode | 0x80 : opcode;\n  if (compressed) outputBuffer[0] |= 0x40;\n\n  switch (secondByte) {\n    case 126:\n      writeUInt16BE.call(outputBuffer, dataLength, 2);\n      break;\n\n    case 127:\n      writeUInt32BE.call(outputBuffer, 0, 2);\n      writeUInt32BE.call(outputBuffer, dataLength, 6);\n  }\n\n  if (maskData) {\n    outputBuffer[1] = secondByte | 0x80;\n    var mask = getRandomMask();\n    outputBuffer[dataOffset - 4] = mask[0];\n    outputBuffer[dataOffset - 3] = mask[1];\n    outputBuffer[dataOffset - 2] = mask[2];\n    outputBuffer[dataOffset - 1] = mask[3];\n\n    if (mergeBuffers) {\n      bufferUtil.mask(data, mask, outputBuffer, dataOffset, dataLength);\n\n      try {\n        this._socket.write(outputBuffer, 'binary', cb);\n      } catch (e) {\n        if (typeof cb == 'function') cb(e);else this.emit('error', e);\n      }\n    } else {\n      bufferUtil.mask(data, mask, data, 0, dataLength);\n\n      try {\n        this._socket.write(outputBuffer, 'binary');\n\n        this._socket.write(data, 'binary', cb);\n      } catch (e) {\n        if (typeof cb == 'function') cb(e);else this.emit('error', e);\n      }\n    }\n  } else {\n    outputBuffer[1] = secondByte;\n\n    if (mergeBuffers) {\n      data.copy(outputBuffer, dataOffset);\n\n      try {\n        this._socket.write(outputBuffer, 'binary', cb);\n      } catch (e) {\n        if (typeof cb == 'function') cb(e);else this.emit('error', e);\n      }\n    } else {\n      try {\n        this._socket.write(outputBuffer, 'binary');\n\n        this._socket.write(data, 'binary', cb);\n      } catch (e) {\n        if (typeof cb == 'function') cb(e);else this.emit('error', e);\n      }\n    }\n  }\n};\n/**\n * Execute message handler buffers\n *\n * @api private\n */\n\n\nSender.prototype.flush = function () {\n  while (!this.processing && this.messageHandlers.length) {\n    this.messageHandlers.shift()();\n  }\n};\n/**\n * Apply extensions to message\n *\n * @api private\n */\n\n\nSender.prototype.applyExtensions = function (data, fin, compress, callback) {\n  if ((data.buffer || data) instanceof ArrayBuffer) {\n    data = getArrayBuffer(data);\n  }\n\n  this.extensions[PerMessageDeflate.extensionName].compress(data, fin, callback);\n};\n\nmodule.exports = Sender;\n\nfunction writeUInt16BE(value, offset) {\n  this[offset] = (value & 0xff00) >> 8;\n  this[offset + 1] = value & 0xff;\n}\n\nfunction writeUInt32BE(value, offset) {\n  this[offset] = (value & 0xff000000) >> 24;\n  this[offset + 1] = (value & 0xff0000) >> 16;\n  this[offset + 2] = (value & 0xff00) >> 8;\n  this[offset + 3] = value & 0xff;\n}\n\nfunction getArrayBuffer(data) {\n  // data is either an ArrayBuffer or ArrayBufferView.\n  var array = new Uint8Array(data.buffer || data),\n      l = data.byteLength || data.length,\n      o = data.byteOffset || 0,\n      buffer = new Buffer(l);\n\n  for (var i = 0; i < l; ++i) {\n    buffer[i] = array[o + i];\n  }\n\n  return buffer;\n}\n\nfunction getRandomMask() {\n  return crypto.randomBytes(4);\n}","map":{"version":3,"sources":["/home/subho/Programming/Internet-Technology/Athena/node_modules/ws/lib/Sender.js"],"names":["events","require","util","crypto","EventEmitter","ErrorCodes","bufferUtil","PerMessageDeflate","Sender","socket","extensions","TypeError","call","_socket","firstFragment","compress","messageHandlers","processing","inherits","prototype","close","code","data","mask","cb","isValidErrorCode","Error","dataBuffer","Buffer","byteLength","writeUInt16BE","length","write","self","push","frameAndSend","flush","ping","options","pong","send","finalFragment","fin","opcode","binary","compressFragment","applyExtensions","err","emit","maskData","compressed","canModifyData","concat","e","isBuffer","buffer","getArrayBuffer","toString","dataLength","dataOffset","secondByte","mergeBuffers","totalLength","outputBuffer","writeUInt32BE","getRandomMask","copy","shift","callback","ArrayBuffer","extensionName","module","exports","value","offset","array","Uint8Array","l","o","byteOffset","i","randomBytes"],"mappings":"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","sourcesContent":["/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nvar events = require('events')\n  , util = require('util')\n  , crypto = require('crypto')\n  , EventEmitter = events.EventEmitter\n  , ErrorCodes = require('./ErrorCodes')\n  , bufferUtil = require('./BufferUtil')\n  , PerMessageDeflate = require('./PerMessageDeflate');\n\n/**\n * HyBi Sender implementation\n */\n\nfunction Sender(socket, extensions) {\n  if (this instanceof Sender === false) {\n    throw new TypeError(\"Classes can't be function-called\");\n  }\n\n  events.EventEmitter.call(this);\n\n  this._socket = socket;\n  this.extensions = extensions || {};\n  this.firstFragment = true;\n  this.compress = false;\n  this.messageHandlers = [];\n  this.processing = false;\n}\n\n/**\n * Inherits from EventEmitter.\n */\n\nutil.inherits(Sender, events.EventEmitter);\n\n/**\n * Sends a close instruction to the remote party.\n *\n * @api public\n */\n\nSender.prototype.close = function(code, data, mask, cb) {\n  if (typeof code !== 'undefined') {\n    if (typeof code !== 'number' ||\n      !ErrorCodes.isValidErrorCode(code)) throw new Error('first argument must be a valid error code number');\n  }\n  code = code || 1000;\n  var dataBuffer = new Buffer(2 + (data ? Buffer.byteLength(data) : 0));\n  writeUInt16BE.call(dataBuffer, code, 0);\n  if (dataBuffer.length > 2) dataBuffer.write(data, 2);\n\n  var self = this;\n  this.messageHandlers.push(function() {\n    self.frameAndSend(0x8, dataBuffer, true, mask);\n    if (typeof cb == 'function') cb();\n  });\n  this.flush();\n};\n\n/**\n * Sends a ping message to the remote party.\n *\n * @api public\n */\n\nSender.prototype.ping = function(data, options) {\n  var mask = options && options.mask;\n  var self = this;\n  this.messageHandlers.push(function() {\n    self.frameAndSend(0x9, data || '', true, mask);\n  });\n  this.flush();\n};\n\n/**\n * Sends a pong message to the remote party.\n *\n * @api public\n */\n\nSender.prototype.pong = function(data, options) {\n  var mask = options && options.mask;\n  var self = this;\n  this.messageHandlers.push(function() {\n    self.frameAndSend(0xa, data || '', true, mask);\n  });\n  this.flush();\n};\n\n/**\n * Sends text or binary data to the remote party.\n *\n * @api public\n */\n\nSender.prototype.send = function(data, options, cb) {\n  var finalFragment = options && options.fin === false ? false : true;\n  var mask = options && options.mask;\n  var compress = options && options.compress;\n  var opcode = options && options.binary ? 2 : 1;\n  if (this.firstFragment === false) {\n    opcode = 0;\n    compress = false;\n  } else {\n    this.firstFragment = false;\n    this.compress = compress;\n  }\n  if (finalFragment) this.firstFragment = true\n\n  var compressFragment = this.compress;\n\n  var self = this;\n  this.messageHandlers.push(function() {\n    if (!data || !compressFragment) {\n      self.frameAndSend(opcode, data, finalFragment, mask, compress, cb);\n      return;\n    }\n\n    self.processing = true;\n    self.applyExtensions(data, finalFragment, compressFragment, function(err, data) {\n      if (err) {\n        if (typeof cb == 'function') cb(err);\n        else self.emit('error', err);\n        return;\n      }\n      self.frameAndSend(opcode, data, finalFragment, mask, compress, cb);\n      self.processing = false;\n      self.flush();\n    });\n  });\n  this.flush();\n};\n\n/**\n * Frames and sends a piece of data according to the HyBi WebSocket protocol.\n *\n * @api private\n */\n\nSender.prototype.frameAndSend = function(opcode, data, finalFragment, maskData, compressed, cb) {\n  var canModifyData = false;\n\n  if (!data) {\n    try {\n      this._socket.write(new Buffer([opcode | (finalFragment ? 0x80 : 0), 0 | (maskData ? 0x80 : 0)].concat(maskData ? [0, 0, 0, 0] : [])), 'binary', cb);\n    }\n    catch (e) {\n      if (typeof cb == 'function') cb(e);\n      else this.emit('error', e);\n    }\n    return;\n  }\n\n  if (!Buffer.isBuffer(data)) {\n    canModifyData = true;\n    if (data && (typeof data.byteLength !== 'undefined' || typeof data.buffer !== 'undefined')) {\n      data = getArrayBuffer(data);\n    } else {\n      //\n      // If people want to send a number, this would allocate the number in\n      // bytes as memory size instead of storing the number as buffer value. So\n      // we need to transform it to string in order to prevent possible\n      // vulnerabilities / memory attacks.\n      //\n      if (typeof data === 'number') data = data.toString();\n\n      data = new Buffer(data);\n    }\n  }\n\n  var dataLength = data.length\n    , dataOffset = maskData ? 6 : 2\n    , secondByte = dataLength;\n\n  if (dataLength >= 65536) {\n    dataOffset += 8;\n    secondByte = 127;\n  }\n  else if (dataLength > 125) {\n    dataOffset += 2;\n    secondByte = 126;\n  }\n\n  var mergeBuffers = dataLength < 32768 || (maskData && !canModifyData);\n  var totalLength = mergeBuffers ? dataLength + dataOffset : dataOffset;\n  var outputBuffer = new Buffer(totalLength);\n  outputBuffer[0] = finalFragment ? opcode | 0x80 : opcode;\n  if (compressed) outputBuffer[0] |= 0x40;\n\n  switch (secondByte) {\n    case 126:\n      writeUInt16BE.call(outputBuffer, dataLength, 2);\n      break;\n    case 127:\n      writeUInt32BE.call(outputBuffer, 0, 2);\n      writeUInt32BE.call(outputBuffer, dataLength, 6);\n  }\n\n  if (maskData) {\n    outputBuffer[1] = secondByte | 0x80;\n    var mask = getRandomMask();\n    outputBuffer[dataOffset - 4] = mask[0];\n    outputBuffer[dataOffset - 3] = mask[1];\n    outputBuffer[dataOffset - 2] = mask[2];\n    outputBuffer[dataOffset - 1] = mask[3];\n    if (mergeBuffers) {\n      bufferUtil.mask(data, mask, outputBuffer, dataOffset, dataLength);\n      try {\n        this._socket.write(outputBuffer, 'binary', cb);\n      }\n      catch (e) {\n        if (typeof cb == 'function') cb(e);\n        else this.emit('error', e);\n      }\n    }\n    else {\n      bufferUtil.mask(data, mask, data, 0, dataLength);\n      try {\n        this._socket.write(outputBuffer, 'binary');\n        this._socket.write(data, 'binary', cb);\n      }\n      catch (e) {\n        if (typeof cb == 'function') cb(e);\n        else this.emit('error', e);\n      }\n    }\n  }\n  else {\n    outputBuffer[1] = secondByte;\n    if (mergeBuffers) {\n      data.copy(outputBuffer, dataOffset);\n      try {\n        this._socket.write(outputBuffer, 'binary', cb);\n      }\n      catch (e) {\n        if (typeof cb == 'function') cb(e);\n        else this.emit('error', e);\n      }\n    }\n    else {\n      try {\n        this._socket.write(outputBuffer, 'binary');\n        this._socket.write(data, 'binary', cb);\n      }\n      catch (e) {\n        if (typeof cb == 'function') cb(e);\n        else this.emit('error', e);\n      }\n    }\n  }\n};\n\n/**\n * Execute message handler buffers\n *\n * @api private\n */\n\nSender.prototype.flush = function() {\n  while (!this.processing && this.messageHandlers.length) {\n    this.messageHandlers.shift()();\n  }\n};\n\n/**\n * Apply extensions to message\n *\n * @api private\n */\n\nSender.prototype.applyExtensions = function(data, fin, compress, callback) {\n  if ((data.buffer || data) instanceof ArrayBuffer) {\n    data = getArrayBuffer(data);\n  }\n  this.extensions[PerMessageDeflate.extensionName].compress(data, fin, callback);\n};\n\nmodule.exports = Sender;\n\nfunction writeUInt16BE(value, offset) {\n  this[offset] = (value & 0xff00)>>8;\n  this[offset+1] = value & 0xff;\n}\n\nfunction writeUInt32BE(value, offset) {\n  this[offset] = (value & 0xff000000)>>24;\n  this[offset+1] = (value & 0xff0000)>>16;\n  this[offset+2] = (value & 0xff00)>>8;\n  this[offset+3] = value & 0xff;\n}\n\nfunction getArrayBuffer(data) {\n  // data is either an ArrayBuffer or ArrayBufferView.\n  var array = new Uint8Array(data.buffer || data)\n    , l = data.byteLength || data.length\n    , o = data.byteOffset || 0\n    , buffer = new Buffer(l);\n  for (var i = 0; i < l; ++i) {\n    buffer[i] = array[o+i];\n  }\n  return buffer;\n}\n\nfunction getRandomMask() {\n  return crypto.randomBytes(4);\n}\n"]},"metadata":{},"sourceType":"script"}