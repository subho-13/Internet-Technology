{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar qs = require('querystring');\n\nvar parse = require('url').parse;\n\nvar base64id = require('base64id');\n\nvar transports = require('./transports');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar Socket = require('./socket');\n\nvar util = require('util');\n\nvar debug = require('debug')('engine');\n\nvar cookieMod = require('cookie');\n/**\n * Module exports.\n */\n\n\nmodule.exports = Server;\n/**\n * Server constructor.\n *\n * @param {Object} options\n * @api public\n */\n\nfunction Server(opts) {\n  if (!(this instanceof Server)) {\n    return new Server(opts);\n  }\n\n  this.clients = {};\n  this.clientsCount = 0;\n  opts = opts || {};\n  this.wsEngine = opts.wsEngine || process.env.EIO_WS_ENGINE;\n  this.pingTimeout = opts.pingTimeout || 60000;\n  this.pingInterval = opts.pingInterval || 25000;\n  this.upgradeTimeout = opts.upgradeTimeout || 10000;\n  this.maxHttpBufferSize = opts.maxHttpBufferSize || 10E7;\n  this.transports = opts.transports || Object.keys(transports);\n  this.allowUpgrades = false !== opts.allowUpgrades;\n  this.allowRequest = opts.allowRequest;\n  this.cookie = false !== opts.cookie ? opts.cookie || 'io' : false;\n  this.cookiePath = false !== opts.cookiePath ? opts.cookiePath || '/' : false;\n  this.cookieHttpOnly = false !== opts.cookieHttpOnly;\n  this.perMessageDeflate = false !== opts.perMessageDeflate ? opts.perMessageDeflate || true : false;\n  this.httpCompression = false !== opts.httpCompression ? opts.httpCompression || {} : false;\n  var self = this; // initialize compression options\n\n  ['perMessageDeflate', 'httpCompression'].forEach(function (type) {\n    var compression = self[type];\n    if (true === compression) self[type] = compression = {};\n\n    if (compression && null == compression.threshold) {\n      compression.threshold = 1024;\n    }\n  }); // initialize websocket server\n\n  if (~this.transports.indexOf('websocket')) {\n    // keep require('ws') as separate expression for packers (browserify, etc)\n    var WebSocketServer = (this.wsEngine ? require(this.wsEngine) : require('ws')).Server;\n    this.ws = new WebSocketServer({\n      noServer: true,\n      clientTracking: false,\n      perMessageDeflate: this.perMessageDeflate,\n      maxPayload: this.maxHttpBufferSize\n    });\n  }\n}\n/**\n * Protocol errors mappings.\n */\n\n\nServer.errors = {\n  UNKNOWN_TRANSPORT: 0,\n  UNKNOWN_SID: 1,\n  BAD_HANDSHAKE_METHOD: 2,\n  BAD_REQUEST: 3\n};\nServer.errorMessages = {\n  0: 'Transport unknown',\n  1: 'Session ID unknown',\n  2: 'Bad handshake method',\n  3: 'Bad request'\n};\n/**\n * Inherits from EventEmitter.\n */\n\nutil.inherits(Server, EventEmitter);\n/**\n * Hash of open clients.\n *\n * @api public\n */\n\nServer.prototype.clients;\n/**\n * Returns a list of available transports for upgrade given a certain transport.\n *\n * @return {Array}\n * @api public\n */\n\nServer.prototype.upgrades = function (transport) {\n  if (!this.allowUpgrades) return [];\n  return transports[transport].upgradesTo || [];\n};\n/**\n * Verifies a request.\n *\n * @param {http.IncomingMessage}\n * @return {Boolean} whether the request is valid\n * @api private\n */\n\n\nServer.prototype.verify = function (req, upgrade, fn) {\n  // transport check\n  var transport = req._query.transport;\n\n  if (!~this.transports.indexOf(transport)) {\n    debug('unknown transport \"%s\"', transport);\n    return fn(Server.errors.UNKNOWN_TRANSPORT, false);\n  } // sid check\n\n\n  var sid = req._query.sid;\n\n  if (sid) {\n    if (!this.clients.hasOwnProperty(sid)) {\n      return fn(Server.errors.UNKNOWN_SID, false);\n    }\n\n    if (!upgrade && this.clients[sid].transport.name !== transport) {\n      debug('bad request: unexpected transport without upgrade');\n      return fn(Server.errors.BAD_REQUEST, false);\n    }\n  } else {\n    // handshake is GET only\n    if ('GET' !== req.method) return fn(Server.errors.BAD_HANDSHAKE_METHOD, false);\n    if (!this.allowRequest) return fn(null, true);\n    return this.allowRequest(req, fn);\n  }\n\n  fn(null, true);\n};\n/**\n * Prepares a request by processing the query string.\n *\n * @api private\n */\n\n\nServer.prototype.prepare = function (req) {\n  // try to leverage pre-existing `req._query` (e.g: from connect)\n  if (!req._query) {\n    req._query = ~req.url.indexOf('?') ? qs.parse(parse(req.url).query) : {};\n  }\n};\n/**\n * Closes all clients.\n *\n * @api public\n */\n\n\nServer.prototype.close = function () {\n  debug('closing all open clients');\n\n  for (var i in this.clients) {\n    if (this.clients.hasOwnProperty(i)) {\n      this.clients[i].close(true);\n    }\n  }\n\n  if (this.ws) {\n    debug('closing webSocketServer');\n    this.ws.close(); // don't delete this.ws because it can be used again if the http server starts listening again\n  }\n\n  return this;\n};\n/**\n * Handles an Engine.IO HTTP request.\n *\n * @param {http.IncomingMessage} request\n * @param {http.ServerResponse|http.OutgoingMessage} response\n * @api public\n */\n\n\nServer.prototype.handleRequest = function (req, res) {\n  debug('handling \"%s\" http request \"%s\"', req.method, req.url);\n  this.prepare(req);\n  req.res = res;\n  var self = this;\n  this.verify(req, false, function (err, success) {\n    if (!success) {\n      sendErrorMessage(req, res, err);\n      return;\n    }\n\n    if (req._query.sid) {\n      debug('setting new request for existing client');\n\n      self.clients[req._query.sid].transport.onRequest(req);\n    } else {\n      self.handshake(req._query.transport, req);\n    }\n  });\n};\n/**\n * Sends an Engine.IO Error Message\n *\n * @param {http.ServerResponse} response\n * @param {code} error code\n * @api private\n */\n\n\nfunction sendErrorMessage(req, res, code) {\n  var headers = {\n    'Content-Type': 'application/json'\n  };\n\n  if (req.headers.origin) {\n    headers['Access-Control-Allow-Credentials'] = 'true';\n    headers['Access-Control-Allow-Origin'] = req.headers.origin;\n  } else {\n    headers['Access-Control-Allow-Origin'] = '*';\n  }\n\n  res.writeHead(400, headers);\n  res.end(JSON.stringify({\n    code: code,\n    message: Server.errorMessages[code]\n  }));\n}\n/**\n * generate a socket id.\n * Overwrite this method to generate your custom socket id\n *\n * @param {Object} request object\n * @api public\n */\n\n\nServer.prototype.generateId = function (req) {\n  return base64id.generateId();\n};\n/**\n * Handshakes a new client.\n *\n * @param {String} transport name\n * @param {Object} request object\n * @api private\n */\n\n\nServer.prototype.handshake = function (transportName, req) {\n  var id = this.generateId(req);\n  debug('handshaking client \"%s\"', id);\n\n  try {\n    var transport = new transports[transportName](req);\n\n    if ('polling' === transportName) {\n      transport.maxHttpBufferSize = this.maxHttpBufferSize;\n      transport.httpCompression = this.httpCompression;\n    } else if ('websocket' === transportName) {\n      transport.perMessageDeflate = this.perMessageDeflate;\n    }\n\n    if (req._query && req._query.b64) {\n      transport.supportsBinary = false;\n    } else {\n      transport.supportsBinary = true;\n    }\n  } catch (e) {\n    sendErrorMessage(req, req.res, Server.errors.BAD_REQUEST);\n    return;\n  }\n\n  var socket = new Socket(id, this, transport, req);\n  var self = this;\n\n  if (false !== this.cookie) {\n    transport.on('headers', function (headers) {\n      headers['Set-Cookie'] = cookieMod.serialize(self.cookie, id, {\n        path: self.cookiePath,\n        httpOnly: self.cookiePath ? self.cookieHttpOnly : false\n      });\n    });\n  }\n\n  transport.onRequest(req);\n  this.clients[id] = socket;\n  this.clientsCount++;\n  socket.once('close', function () {\n    delete self.clients[id];\n    self.clientsCount--;\n  });\n  this.emit('connection', socket);\n};\n/**\n * Handles an Engine.IO HTTP Upgrade.\n *\n * @api public\n */\n\n\nServer.prototype.handleUpgrade = function (req, socket, upgradeHead) {\n  this.prepare(req);\n  var self = this;\n  this.verify(req, true, function (err, success) {\n    if (!success) {\n      abortConnection(socket, err);\n      return;\n    }\n\n    var head = new Buffer(upgradeHead.length);\n    upgradeHead.copy(head);\n    upgradeHead = null; // delegate to ws\n\n    self.ws.handleUpgrade(req, socket, head, function (conn) {\n      self.onWebSocket(req, conn);\n    });\n  });\n};\n/**\n * Called upon a ws.io connection.\n *\n * @param {ws.Socket} websocket\n * @api private\n */\n\n\nServer.prototype.onWebSocket = function (req, socket) {\n  socket.on('error', onUpgradeError);\n\n  if (!transports[req._query.transport].prototype.handlesUpgrades) {\n    debug('transport doesnt handle upgraded requests');\n    socket.close();\n    return;\n  } // get client id\n\n\n  var id = req._query.sid; // keep a reference to the ws.Socket\n\n  req.websocket = socket;\n\n  if (id) {\n    var client = this.clients[id];\n\n    if (!client) {\n      debug('upgrade attempt for closed client');\n      socket.close();\n    } else if (client.upgrading) {\n      debug('transport has already been trying to upgrade');\n      socket.close();\n    } else if (client.upgraded) {\n      debug('transport had already been upgraded');\n      socket.close();\n    } else {\n      debug('upgrading existing transport'); // transport error handling takes over\n\n      socket.removeListener('error', onUpgradeError);\n      var transport = new transports[req._query.transport](req);\n\n      if (req._query && req._query.b64) {\n        transport.supportsBinary = false;\n      } else {\n        transport.supportsBinary = true;\n      }\n\n      transport.perMessageDeflate = this.perMessageDeflate;\n      client.maybeUpgrade(transport);\n    }\n  } else {\n    // transport error handling takes over\n    socket.removeListener('error', onUpgradeError);\n    this.handshake(req._query.transport, req);\n  }\n\n  function onUpgradeError() {\n    debug('websocket error before upgrade'); // socket.close() not needed\n  }\n};\n/**\n * Captures upgrade requests for a http.Server.\n *\n * @param {http.Server} server\n * @param {Object} options\n * @api public\n */\n\n\nServer.prototype.attach = function (server, options) {\n  var self = this;\n  options = options || {};\n  var path = (options.path || '/engine.io').replace(/\\/$/, '');\n  var destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000; // normalize path\n\n  path += '/';\n\n  function check(req) {\n    return path === req.url.substr(0, path.length);\n  } // cache and clean up listeners\n\n\n  var listeners = server.listeners('request').slice(0);\n  server.removeAllListeners('request');\n  server.on('close', self.close.bind(self)); // add request handler\n\n  server.on('request', function (req, res) {\n    if (check(req)) {\n      debug('intercepting request for path \"%s\"', path);\n      self.handleRequest(req, res);\n    } else {\n      for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i].call(server, req, res);\n      }\n    }\n  });\n\n  if (~self.transports.indexOf('websocket')) {\n    server.on('upgrade', function (req, socket, head) {\n      if (check(req)) {\n        self.handleUpgrade(req, socket, head);\n      } else if (false !== options.destroyUpgrade) {\n        // default node behavior is to disconnect when no handlers\n        // but by adding a handler, we prevent that\n        // and if no eio thing handles the upgrade\n        // then the socket needs to die!\n        setTimeout(function () {\n          if (socket.writable && socket.bytesWritten <= 0) {\n            return socket.end();\n          }\n        }, destroyUpgradeTimeout);\n      }\n    });\n  }\n};\n/**\n * Closes the connection\n *\n * @param {net.Socket} socket\n * @param {code} error code\n * @api private\n */\n\n\nfunction abortConnection(socket, code) {\n  if (socket.writable) {\n    var message = Server.errorMessages.hasOwnProperty(code) ? Server.errorMessages[code] : code || '';\n    var length = Buffer.byteLength(message);\n    socket.write('HTTP/1.1 400 Bad Request\\r\\n' + 'Connection: close\\r\\n' + 'Content-type: text/html\\r\\n' + 'Content-Length: ' + length + '\\r\\n' + '\\r\\n' + message);\n  }\n\n  socket.destroy();\n}","map":{"version":3,"sources":["/home/subho/Programming/Internet-Technology/Athena/node_modules/engine.io/lib/server.js"],"names":["qs","require","parse","base64id","transports","EventEmitter","Socket","util","debug","cookieMod","module","exports","Server","opts","clients","clientsCount","wsEngine","process","env","EIO_WS_ENGINE","pingTimeout","pingInterval","upgradeTimeout","maxHttpBufferSize","Object","keys","allowUpgrades","allowRequest","cookie","cookiePath","cookieHttpOnly","perMessageDeflate","httpCompression","self","forEach","type","compression","threshold","indexOf","WebSocketServer","ws","noServer","clientTracking","maxPayload","errors","UNKNOWN_TRANSPORT","UNKNOWN_SID","BAD_HANDSHAKE_METHOD","BAD_REQUEST","errorMessages","inherits","prototype","upgrades","transport","upgradesTo","verify","req","upgrade","fn","_query","sid","hasOwnProperty","name","method","prepare","url","query","close","i","handleRequest","res","err","success","sendErrorMessage","onRequest","handshake","code","headers","origin","writeHead","end","JSON","stringify","message","generateId","transportName","id","b64","supportsBinary","e","socket","on","serialize","path","httpOnly","once","emit","handleUpgrade","upgradeHead","abortConnection","head","Buffer","length","copy","conn","onWebSocket","onUpgradeError","handlesUpgrades","websocket","client","upgrading","upgraded","removeListener","maybeUpgrade","attach","server","options","replace","destroyUpgradeTimeout","check","substr","listeners","slice","removeAllListeners","bind","l","call","destroyUpgrade","setTimeout","writable","bytesWritten","byteLength","write","destroy"],"mappings":"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","sourcesContent":["\n/**\n * Module dependencies.\n */\n\nvar qs = require('querystring');\nvar parse = require('url').parse;\nvar base64id = require('base64id');\nvar transports = require('./transports');\nvar EventEmitter = require('events').EventEmitter;\nvar Socket = require('./socket');\nvar util = require('util');\nvar debug = require('debug')('engine');\nvar cookieMod = require('cookie');\n\n/**\n * Module exports.\n */\n\nmodule.exports = Server;\n\n/**\n * Server constructor.\n *\n * @param {Object} options\n * @api public\n */\n\nfunction Server (opts) {\n  if (!(this instanceof Server)) {\n    return new Server(opts);\n  }\n\n  this.clients = {};\n  this.clientsCount = 0;\n\n  opts = opts || {};\n\n  this.wsEngine = opts.wsEngine || process.env.EIO_WS_ENGINE;\n  this.pingTimeout = opts.pingTimeout || 60000;\n  this.pingInterval = opts.pingInterval || 25000;\n  this.upgradeTimeout = opts.upgradeTimeout || 10000;\n  this.maxHttpBufferSize = opts.maxHttpBufferSize || 10E7;\n  this.transports = opts.transports || Object.keys(transports);\n  this.allowUpgrades = false !== opts.allowUpgrades;\n  this.allowRequest = opts.allowRequest;\n  this.cookie = false !== opts.cookie ? (opts.cookie || 'io') : false;\n  this.cookiePath = false !== opts.cookiePath ? (opts.cookiePath || '/') : false;\n  this.cookieHttpOnly = false !== opts.cookieHttpOnly;\n  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || true) : false;\n  this.httpCompression = false !== opts.httpCompression ? (opts.httpCompression || {}) : false;\n\n  var self = this;\n\n  // initialize compression options\n  ['perMessageDeflate', 'httpCompression'].forEach(function (type) {\n    var compression = self[type];\n    if (true === compression) self[type] = compression = {};\n    if (compression && null == compression.threshold) {\n      compression.threshold = 1024;\n    }\n  });\n\n  // initialize websocket server\n  if (~this.transports.indexOf('websocket')) {\n    // keep require('ws') as separate expression for packers (browserify, etc)\n    var WebSocketServer = (this.wsEngine ? require(this.wsEngine) : require('ws')).Server;\n    this.ws = new WebSocketServer({\n      noServer: true,\n      clientTracking: false,\n      perMessageDeflate: this.perMessageDeflate,\n      maxPayload: this.maxHttpBufferSize\n    });\n  }\n}\n\n/**\n * Protocol errors mappings.\n */\n\nServer.errors = {\n  UNKNOWN_TRANSPORT: 0,\n  UNKNOWN_SID: 1,\n  BAD_HANDSHAKE_METHOD: 2,\n  BAD_REQUEST: 3\n};\n\nServer.errorMessages = {\n  0: 'Transport unknown',\n  1: 'Session ID unknown',\n  2: 'Bad handshake method',\n  3: 'Bad request'\n};\n\n/**\n * Inherits from EventEmitter.\n */\n\nutil.inherits(Server, EventEmitter);\n\n/**\n * Hash of open clients.\n *\n * @api public\n */\n\nServer.prototype.clients;\n\n/**\n * Returns a list of available transports for upgrade given a certain transport.\n *\n * @return {Array}\n * @api public\n */\n\nServer.prototype.upgrades = function (transport) {\n  if (!this.allowUpgrades) return [];\n  return transports[transport].upgradesTo || [];\n};\n\n/**\n * Verifies a request.\n *\n * @param {http.IncomingMessage}\n * @return {Boolean} whether the request is valid\n * @api private\n */\n\nServer.prototype.verify = function (req, upgrade, fn) {\n  // transport check\n  var transport = req._query.transport;\n  if (!~this.transports.indexOf(transport)) {\n    debug('unknown transport \"%s\"', transport);\n    return fn(Server.errors.UNKNOWN_TRANSPORT, false);\n  }\n\n  // sid check\n  var sid = req._query.sid;\n  if (sid) {\n    if (!this.clients.hasOwnProperty(sid)) {\n      return fn(Server.errors.UNKNOWN_SID, false);\n    }\n    if (!upgrade && this.clients[sid].transport.name !== transport) {\n      debug('bad request: unexpected transport without upgrade');\n      return fn(Server.errors.BAD_REQUEST, false);\n    }\n  } else {\n    // handshake is GET only\n    if ('GET' !== req.method) return fn(Server.errors.BAD_HANDSHAKE_METHOD, false);\n    if (!this.allowRequest) return fn(null, true);\n    return this.allowRequest(req, fn);\n  }\n\n  fn(null, true);\n};\n\n/**\n * Prepares a request by processing the query string.\n *\n * @api private\n */\n\nServer.prototype.prepare = function (req) {\n  // try to leverage pre-existing `req._query` (e.g: from connect)\n  if (!req._query) {\n    req._query = ~req.url.indexOf('?') ? qs.parse(parse(req.url).query) : {};\n  }\n};\n\n/**\n * Closes all clients.\n *\n * @api public\n */\n\nServer.prototype.close = function () {\n  debug('closing all open clients');\n  for (var i in this.clients) {\n    if (this.clients.hasOwnProperty(i)) {\n      this.clients[i].close(true);\n    }\n  }\n  if (this.ws) {\n    debug('closing webSocketServer');\n    this.ws.close();\n    // don't delete this.ws because it can be used again if the http server starts listening again\n  }\n  return this;\n};\n\n/**\n * Handles an Engine.IO HTTP request.\n *\n * @param {http.IncomingMessage} request\n * @param {http.ServerResponse|http.OutgoingMessage} response\n * @api public\n */\n\nServer.prototype.handleRequest = function (req, res) {\n  debug('handling \"%s\" http request \"%s\"', req.method, req.url);\n  this.prepare(req);\n  req.res = res;\n\n  var self = this;\n  this.verify(req, false, function (err, success) {\n    if (!success) {\n      sendErrorMessage(req, res, err);\n      return;\n    }\n\n    if (req._query.sid) {\n      debug('setting new request for existing client');\n      self.clients[req._query.sid].transport.onRequest(req);\n    } else {\n      self.handshake(req._query.transport, req);\n    }\n  });\n};\n\n/**\n * Sends an Engine.IO Error Message\n *\n * @param {http.ServerResponse} response\n * @param {code} error code\n * @api private\n */\n\nfunction sendErrorMessage (req, res, code) {\n  var headers = { 'Content-Type': 'application/json' };\n\n  if (req.headers.origin) {\n    headers['Access-Control-Allow-Credentials'] = 'true';\n    headers['Access-Control-Allow-Origin'] = req.headers.origin;\n  } else {\n    headers['Access-Control-Allow-Origin'] = '*';\n  }\n  res.writeHead(400, headers);\n  res.end(JSON.stringify({\n    code: code,\n    message: Server.errorMessages[code]\n  }));\n}\n\n/**\n * generate a socket id.\n * Overwrite this method to generate your custom socket id\n *\n * @param {Object} request object\n * @api public\n */\n\nServer.prototype.generateId = function (req) {\n  return base64id.generateId();\n};\n\n/**\n * Handshakes a new client.\n *\n * @param {String} transport name\n * @param {Object} request object\n * @api private\n */\n\nServer.prototype.handshake = function (transportName, req) {\n  var id = this.generateId(req);\n\n  debug('handshaking client \"%s\"', id);\n\n  try {\n    var transport = new transports[transportName](req);\n    if ('polling' === transportName) {\n      transport.maxHttpBufferSize = this.maxHttpBufferSize;\n      transport.httpCompression = this.httpCompression;\n    } else if ('websocket' === transportName) {\n      transport.perMessageDeflate = this.perMessageDeflate;\n    }\n\n    if (req._query && req._query.b64) {\n      transport.supportsBinary = false;\n    } else {\n      transport.supportsBinary = true;\n    }\n  } catch (e) {\n    sendErrorMessage(req, req.res, Server.errors.BAD_REQUEST);\n    return;\n  }\n  var socket = new Socket(id, this, transport, req);\n  var self = this;\n\n  if (false !== this.cookie) {\n    transport.on('headers', function (headers) {\n      headers['Set-Cookie'] = cookieMod.serialize(self.cookie, id,\n        {\n          path: self.cookiePath,\n          httpOnly: self.cookiePath ? self.cookieHttpOnly : false\n        });\n    });\n  }\n\n  transport.onRequest(req);\n\n  this.clients[id] = socket;\n  this.clientsCount++;\n\n  socket.once('close', function () {\n    delete self.clients[id];\n    self.clientsCount--;\n  });\n\n  this.emit('connection', socket);\n};\n\n/**\n * Handles an Engine.IO HTTP Upgrade.\n *\n * @api public\n */\n\nServer.prototype.handleUpgrade = function (req, socket, upgradeHead) {\n  this.prepare(req);\n\n  var self = this;\n  this.verify(req, true, function (err, success) {\n    if (!success) {\n      abortConnection(socket, err);\n      return;\n    }\n\n    var head = new Buffer(upgradeHead.length);\n    upgradeHead.copy(head);\n    upgradeHead = null;\n\n    // delegate to ws\n    self.ws.handleUpgrade(req, socket, head, function (conn) {\n      self.onWebSocket(req, conn);\n    });\n  });\n};\n\n/**\n * Called upon a ws.io connection.\n *\n * @param {ws.Socket} websocket\n * @api private\n */\n\nServer.prototype.onWebSocket = function (req, socket) {\n  socket.on('error', onUpgradeError);\n\n  if (!transports[req._query.transport].prototype.handlesUpgrades) {\n    debug('transport doesnt handle upgraded requests');\n    socket.close();\n    return;\n  }\n\n  // get client id\n  var id = req._query.sid;\n\n  // keep a reference to the ws.Socket\n  req.websocket = socket;\n\n  if (id) {\n    var client = this.clients[id];\n    if (!client) {\n      debug('upgrade attempt for closed client');\n      socket.close();\n    } else if (client.upgrading) {\n      debug('transport has already been trying to upgrade');\n      socket.close();\n    } else if (client.upgraded) {\n      debug('transport had already been upgraded');\n      socket.close();\n    } else {\n      debug('upgrading existing transport');\n\n      // transport error handling takes over\n      socket.removeListener('error', onUpgradeError);\n\n      var transport = new transports[req._query.transport](req);\n      if (req._query && req._query.b64) {\n        transport.supportsBinary = false;\n      } else {\n        transport.supportsBinary = true;\n      }\n      transport.perMessageDeflate = this.perMessageDeflate;\n      client.maybeUpgrade(transport);\n    }\n  } else {\n    // transport error handling takes over\n    socket.removeListener('error', onUpgradeError);\n\n    this.handshake(req._query.transport, req);\n  }\n\n  function onUpgradeError () {\n    debug('websocket error before upgrade');\n    // socket.close() not needed\n  }\n};\n\n/**\n * Captures upgrade requests for a http.Server.\n *\n * @param {http.Server} server\n * @param {Object} options\n * @api public\n */\n\nServer.prototype.attach = function (server, options) {\n  var self = this;\n  options = options || {};\n  var path = (options.path || '/engine.io').replace(/\\/$/, '');\n\n  var destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000;\n\n  // normalize path\n  path += '/';\n\n  function check (req) {\n    return path === req.url.substr(0, path.length);\n  }\n\n  // cache and clean up listeners\n  var listeners = server.listeners('request').slice(0);\n  server.removeAllListeners('request');\n  server.on('close', self.close.bind(self));\n\n  // add request handler\n  server.on('request', function (req, res) {\n    if (check(req)) {\n      debug('intercepting request for path \"%s\"', path);\n      self.handleRequest(req, res);\n    } else {\n      for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i].call(server, req, res);\n      }\n    }\n  });\n\n  if (~self.transports.indexOf('websocket')) {\n    server.on('upgrade', function (req, socket, head) {\n      if (check(req)) {\n        self.handleUpgrade(req, socket, head);\n      } else if (false !== options.destroyUpgrade) {\n        // default node behavior is to disconnect when no handlers\n        // but by adding a handler, we prevent that\n        // and if no eio thing handles the upgrade\n        // then the socket needs to die!\n        setTimeout(function () {\n          if (socket.writable && socket.bytesWritten <= 0) {\n            return socket.end();\n          }\n        }, destroyUpgradeTimeout);\n      }\n    });\n  }\n};\n\n/**\n * Closes the connection\n *\n * @param {net.Socket} socket\n * @param {code} error code\n * @api private\n */\n\nfunction abortConnection (socket, code) {\n  if (socket.writable) {\n    var message = Server.errorMessages.hasOwnProperty(code) ? Server.errorMessages[code] : (code || '');\n    var length = Buffer.byteLength(message);\n    socket.write(\n      'HTTP/1.1 400 Bad Request\\r\\n' +\n      'Connection: close\\r\\n' +\n      'Content-type: text/html\\r\\n' +\n      'Content-Length: ' + length + '\\r\\n' +\n      '\\r\\n' +\n      message\n    );\n  }\n  socket.destroy();\n}\n"]},"metadata":{},"sourceType":"script"}