{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar eio = require('engine.io-client');\n\nvar Socket = require('./socket');\n\nvar Emitter = require('component-emitter');\n\nvar parser = require('socket.io-parser');\n\nvar on = require('./on');\n\nvar bind = require('component-bind');\n\nvar debug = require('debug')('socket.io-client:manager');\n\nvar indexOf = require('indexof');\n\nvar Backoff = require('backo2');\n/**\n * IE6+ hasOwnProperty\n */\n\n\nvar has = Object.prototype.hasOwnProperty;\n/**\n * Module exports\n */\n\nmodule.exports = Manager;\n/**\n * `Manager` constructor.\n *\n * @param {String} engine instance or engine uri/opts\n * @param {Object} options\n * @api public\n */\n\nfunction Manager(uri, opts) {\n  if (!(this instanceof Manager)) return new Manager(uri, opts);\n\n  if (uri && 'object' === typeof uri) {\n    opts = uri;\n    uri = undefined;\n  }\n\n  opts = opts || {};\n  opts.path = opts.path || '/socket.io';\n  this.nsps = {};\n  this.subs = [];\n  this.opts = opts;\n  this.reconnection(opts.reconnection !== false);\n  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n  this.reconnectionDelay(opts.reconnectionDelay || 1000);\n  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n  this.randomizationFactor(opts.randomizationFactor || 0.5);\n  this.backoff = new Backoff({\n    min: this.reconnectionDelay(),\n    max: this.reconnectionDelayMax(),\n    jitter: this.randomizationFactor()\n  });\n  this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n  this.readyState = 'closed';\n  this.uri = uri;\n  this.connecting = [];\n  this.lastPing = null;\n  this.encoding = false;\n  this.packetBuffer = [];\n  this.encoder = new parser.Encoder();\n  this.decoder = new parser.Decoder();\n  this.autoConnect = opts.autoConnect !== false;\n  if (this.autoConnect) this.open();\n}\n/**\n * Propagate given event to sockets and emit on `this`\n *\n * @api private\n */\n\n\nManager.prototype.emitAll = function () {\n  this.emit.apply(this, arguments);\n\n  for (var nsp in this.nsps) {\n    if (has.call(this.nsps, nsp)) {\n      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);\n    }\n  }\n};\n/**\n * Update `socket.id` of all sockets\n *\n * @api private\n */\n\n\nManager.prototype.updateSocketIds = function () {\n  for (var nsp in this.nsps) {\n    if (has.call(this.nsps, nsp)) {\n      this.nsps[nsp].id = this.engine.id;\n    }\n  }\n};\n/**\n * Mix in `Emitter`.\n */\n\n\nEmitter(Manager.prototype);\n/**\n * Sets the `reconnection` config.\n *\n * @param {Boolean} true/false if it should automatically reconnect\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnection = function (v) {\n  if (!arguments.length) return this._reconnection;\n  this._reconnection = !!v;\n  return this;\n};\n/**\n * Sets the reconnection attempts config.\n *\n * @param {Number} max reconnection attempts before giving up\n * @return {Manager} self or value\n * @api public\n */\n\n\nManager.prototype.reconnectionAttempts = function (v) {\n  if (!arguments.length) return this._reconnectionAttempts;\n  this._reconnectionAttempts = v;\n  return this;\n};\n/**\n * Sets the delay between reconnections.\n *\n * @param {Number} delay\n * @return {Manager} self or value\n * @api public\n */\n\n\nManager.prototype.reconnectionDelay = function (v) {\n  if (!arguments.length) return this._reconnectionDelay;\n  this._reconnectionDelay = v;\n  this.backoff && this.backoff.setMin(v);\n  return this;\n};\n\nManager.prototype.randomizationFactor = function (v) {\n  if (!arguments.length) return this._randomizationFactor;\n  this._randomizationFactor = v;\n  this.backoff && this.backoff.setJitter(v);\n  return this;\n};\n/**\n * Sets the maximum delay between reconnections.\n *\n * @param {Number} delay\n * @return {Manager} self or value\n * @api public\n */\n\n\nManager.prototype.reconnectionDelayMax = function (v) {\n  if (!arguments.length) return this._reconnectionDelayMax;\n  this._reconnectionDelayMax = v;\n  this.backoff && this.backoff.setMax(v);\n  return this;\n};\n/**\n * Sets the connection timeout. `false` to disable\n *\n * @return {Manager} self or value\n * @api public\n */\n\n\nManager.prototype.timeout = function (v) {\n  if (!arguments.length) return this._timeout;\n  this._timeout = v;\n  return this;\n};\n/**\n * Starts trying to reconnect if reconnection is enabled and we have not\n * started reconnecting yet\n *\n * @api private\n */\n\n\nManager.prototype.maybeReconnectOnOpen = function () {\n  // Only try to reconnect if it's the first time we're connecting\n  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {\n    // keeps reconnection from firing twice for the same reconnection loop\n    this.reconnect();\n  }\n};\n/**\n * Sets the current transport `socket`.\n *\n * @param {Function} optional, callback\n * @return {Manager} self\n * @api public\n */\n\n\nManager.prototype.open = Manager.prototype.connect = function (fn, opts) {\n  debug('readyState %s', this.readyState);\n  if (~this.readyState.indexOf('open')) return this;\n  debug('opening %s', this.uri);\n  this.engine = eio(this.uri, this.opts);\n  var socket = this.engine;\n  var self = this;\n  this.readyState = 'opening';\n  this.skipReconnect = false; // emit `open`\n\n  var openSub = on(socket, 'open', function () {\n    self.onopen();\n    fn && fn();\n  }); // emit `connect_error`\n\n  var errorSub = on(socket, 'error', function (data) {\n    debug('connect_error');\n    self.cleanup();\n    self.readyState = 'closed';\n    self.emitAll('connect_error', data);\n\n    if (fn) {\n      var err = new Error('Connection error');\n      err.data = data;\n      fn(err);\n    } else {\n      // Only do this if there is no fn to handle the error\n      self.maybeReconnectOnOpen();\n    }\n  }); // emit `connect_timeout`\n\n  if (false !== this._timeout) {\n    var timeout = this._timeout;\n    debug('connect attempt will timeout after %d', timeout); // set timer\n\n    var timer = setTimeout(function () {\n      debug('connect attempt timed out after %d', timeout);\n      openSub.destroy();\n      socket.close();\n      socket.emit('error', 'timeout');\n      self.emitAll('connect_timeout', timeout);\n    }, timeout);\n    this.subs.push({\n      destroy: function () {\n        clearTimeout(timer);\n      }\n    });\n  }\n\n  this.subs.push(openSub);\n  this.subs.push(errorSub);\n  return this;\n};\n/**\n * Called upon transport open.\n *\n * @api private\n */\n\n\nManager.prototype.onopen = function () {\n  debug('open'); // clear old subs\n\n  this.cleanup(); // mark as open\n\n  this.readyState = 'open';\n  this.emit('open'); // add new subs\n\n  var socket = this.engine;\n  this.subs.push(on(socket, 'data', bind(this, 'ondata')));\n  this.subs.push(on(socket, 'ping', bind(this, 'onping')));\n  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));\n  this.subs.push(on(socket, 'error', bind(this, 'onerror')));\n  this.subs.push(on(socket, 'close', bind(this, 'onclose')));\n  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));\n};\n/**\n * Called upon a ping.\n *\n * @api private\n */\n\n\nManager.prototype.onping = function () {\n  this.lastPing = new Date();\n  this.emitAll('ping');\n};\n/**\n * Called upon a packet.\n *\n * @api private\n */\n\n\nManager.prototype.onpong = function () {\n  this.emitAll('pong', new Date() - this.lastPing);\n};\n/**\n * Called with data.\n *\n * @api private\n */\n\n\nManager.prototype.ondata = function (data) {\n  this.decoder.add(data);\n};\n/**\n * Called when parser fully decodes a packet.\n *\n * @api private\n */\n\n\nManager.prototype.ondecoded = function (packet) {\n  this.emit('packet', packet);\n};\n/**\n * Called upon socket error.\n *\n * @api private\n */\n\n\nManager.prototype.onerror = function (err) {\n  debug('error', err);\n  this.emitAll('error', err);\n};\n/**\n * Creates a new socket for the given `nsp`.\n *\n * @return {Socket}\n * @api public\n */\n\n\nManager.prototype.socket = function (nsp, opts) {\n  var socket = this.nsps[nsp];\n\n  if (!socket) {\n    socket = new Socket(this, nsp, opts);\n    this.nsps[nsp] = socket;\n    var self = this;\n    socket.on('connecting', onConnecting);\n    socket.on('connect', function () {\n      socket.id = self.engine.id;\n    });\n\n    if (this.autoConnect) {\n      // manually call here since connecting evnet is fired before listening\n      onConnecting();\n    }\n  }\n\n  function onConnecting() {\n    if (!~indexOf(self.connecting, socket)) {\n      self.connecting.push(socket);\n    }\n  }\n\n  return socket;\n};\n/**\n * Called upon a socket close.\n *\n * @param {Socket} socket\n */\n\n\nManager.prototype.destroy = function (socket) {\n  var index = indexOf(this.connecting, socket);\n  if (~index) this.connecting.splice(index, 1);\n  if (this.connecting.length) return;\n  this.close();\n};\n/**\n * Writes a packet.\n *\n * @param {Object} packet\n * @api private\n */\n\n\nManager.prototype.packet = function (packet) {\n  debug('writing packet %j', packet);\n  var self = this;\n  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;\n\n  if (!self.encoding) {\n    // encode, then write to engine with result\n    self.encoding = true;\n    this.encoder.encode(packet, function (encodedPackets) {\n      for (var i = 0; i < encodedPackets.length; i++) {\n        self.engine.write(encodedPackets[i], packet.options);\n      }\n\n      self.encoding = false;\n      self.processPacketQueue();\n    });\n  } else {\n    // add packet to the queue\n    self.packetBuffer.push(packet);\n  }\n};\n/**\n * If packet buffer is non-empty, begins encoding the\n * next packet in line.\n *\n * @api private\n */\n\n\nManager.prototype.processPacketQueue = function () {\n  if (this.packetBuffer.length > 0 && !this.encoding) {\n    var pack = this.packetBuffer.shift();\n    this.packet(pack);\n  }\n};\n/**\n * Clean up transport subscriptions and packet buffer.\n *\n * @api private\n */\n\n\nManager.prototype.cleanup = function () {\n  debug('cleanup');\n  var subsLength = this.subs.length;\n\n  for (var i = 0; i < subsLength; i++) {\n    var sub = this.subs.shift();\n    sub.destroy();\n  }\n\n  this.packetBuffer = [];\n  this.encoding = false;\n  this.lastPing = null;\n  this.decoder.destroy();\n};\n/**\n * Close the current socket.\n *\n * @api private\n */\n\n\nManager.prototype.close = Manager.prototype.disconnect = function () {\n  debug('disconnect');\n  this.skipReconnect = true;\n  this.reconnecting = false;\n\n  if ('opening' === this.readyState) {\n    // `onclose` will not fire because\n    // an open event never happened\n    this.cleanup();\n  }\n\n  this.backoff.reset();\n  this.readyState = 'closed';\n  if (this.engine) this.engine.close();\n};\n/**\n * Called upon engine close.\n *\n * @api private\n */\n\n\nManager.prototype.onclose = function (reason) {\n  debug('onclose');\n  this.cleanup();\n  this.backoff.reset();\n  this.readyState = 'closed';\n  this.emit('close', reason);\n\n  if (this._reconnection && !this.skipReconnect) {\n    this.reconnect();\n  }\n};\n/**\n * Attempt a reconnection.\n *\n * @api private\n */\n\n\nManager.prototype.reconnect = function () {\n  if (this.reconnecting || this.skipReconnect) return this;\n  var self = this;\n\n  if (this.backoff.attempts >= this._reconnectionAttempts) {\n    debug('reconnect failed');\n    this.backoff.reset();\n    this.emitAll('reconnect_failed');\n    this.reconnecting = false;\n  } else {\n    var delay = this.backoff.duration();\n    debug('will wait %dms before reconnect attempt', delay);\n    this.reconnecting = true;\n    var timer = setTimeout(function () {\n      if (self.skipReconnect) return;\n      debug('attempting reconnect');\n      self.emitAll('reconnect_attempt', self.backoff.attempts);\n      self.emitAll('reconnecting', self.backoff.attempts); // check again for the case socket closed in above events\n\n      if (self.skipReconnect) return;\n      self.open(function (err) {\n        if (err) {\n          debug('reconnect attempt error');\n          self.reconnecting = false;\n          self.reconnect();\n          self.emitAll('reconnect_error', err.data);\n        } else {\n          debug('reconnect success');\n          self.onreconnect();\n        }\n      });\n    }, delay);\n    this.subs.push({\n      destroy: function () {\n        clearTimeout(timer);\n      }\n    });\n  }\n};\n/**\n * Called upon successful reconnect.\n *\n * @api private\n */\n\n\nManager.prototype.onreconnect = function () {\n  var attempt = this.backoff.attempts;\n  this.reconnecting = false;\n  this.backoff.reset();\n  this.updateSocketIds();\n  this.emitAll('reconnect', attempt);\n};","map":{"version":3,"sources":["/home/subho/Programming/Internet-Technology/Athena/node_modules/socket.io-client/lib/manager.js"],"names":["eio","require","Socket","Emitter","parser","on","bind","debug","indexOf","Backoff","has","Object","prototype","hasOwnProperty","module","exports","Manager","uri","opts","undefined","path","nsps","subs","reconnection","reconnectionAttempts","Infinity","reconnectionDelay","reconnectionDelayMax","randomizationFactor","backoff","min","max","jitter","timeout","readyState","connecting","lastPing","encoding","packetBuffer","encoder","Encoder","decoder","Decoder","autoConnect","open","emitAll","emit","apply","arguments","nsp","call","updateSocketIds","id","engine","v","length","_reconnection","_reconnectionAttempts","_reconnectionDelay","setMin","_randomizationFactor","setJitter","_reconnectionDelayMax","setMax","_timeout","maybeReconnectOnOpen","reconnecting","attempts","reconnect","connect","fn","socket","self","skipReconnect","openSub","onopen","errorSub","data","cleanup","err","Error","timer","setTimeout","destroy","close","push","clearTimeout","onping","Date","onpong","ondata","add","ondecoded","packet","onerror","onConnecting","index","splice","query","type","encode","encodedPackets","i","write","options","processPacketQueue","pack","shift","subsLength","sub","disconnect","reset","onclose","reason","delay","duration","onreconnect","attempt"],"mappings":"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","sourcesContent":["\n/**\n * Module dependencies.\n */\n\nvar eio = require('engine.io-client');\nvar Socket = require('./socket');\nvar Emitter = require('component-emitter');\nvar parser = require('socket.io-parser');\nvar on = require('./on');\nvar bind = require('component-bind');\nvar debug = require('debug')('socket.io-client:manager');\nvar indexOf = require('indexof');\nvar Backoff = require('backo2');\n\n/**\n * IE6+ hasOwnProperty\n */\n\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * Module exports\n */\n\nmodule.exports = Manager;\n\n/**\n * `Manager` constructor.\n *\n * @param {String} engine instance or engine uri/opts\n * @param {Object} options\n * @api public\n */\n\nfunction Manager (uri, opts) {\n  if (!(this instanceof Manager)) return new Manager(uri, opts);\n  if (uri && ('object' === typeof uri)) {\n    opts = uri;\n    uri = undefined;\n  }\n  opts = opts || {};\n\n  opts.path = opts.path || '/socket.io';\n  this.nsps = {};\n  this.subs = [];\n  this.opts = opts;\n  this.reconnection(opts.reconnection !== false);\n  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n  this.reconnectionDelay(opts.reconnectionDelay || 1000);\n  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n  this.randomizationFactor(opts.randomizationFactor || 0.5);\n  this.backoff = new Backoff({\n    min: this.reconnectionDelay(),\n    max: this.reconnectionDelayMax(),\n    jitter: this.randomizationFactor()\n  });\n  this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n  this.readyState = 'closed';\n  this.uri = uri;\n  this.connecting = [];\n  this.lastPing = null;\n  this.encoding = false;\n  this.packetBuffer = [];\n  this.encoder = new parser.Encoder();\n  this.decoder = new parser.Decoder();\n  this.autoConnect = opts.autoConnect !== false;\n  if (this.autoConnect) this.open();\n}\n\n/**\n * Propagate given event to sockets and emit on `this`\n *\n * @api private\n */\n\nManager.prototype.emitAll = function () {\n  this.emit.apply(this, arguments);\n  for (var nsp in this.nsps) {\n    if (has.call(this.nsps, nsp)) {\n      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);\n    }\n  }\n};\n\n/**\n * Update `socket.id` of all sockets\n *\n * @api private\n */\n\nManager.prototype.updateSocketIds = function () {\n  for (var nsp in this.nsps) {\n    if (has.call(this.nsps, nsp)) {\n      this.nsps[nsp].id = this.engine.id;\n    }\n  }\n};\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Manager.prototype);\n\n/**\n * Sets the `reconnection` config.\n *\n * @param {Boolean} true/false if it should automatically reconnect\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnection = function (v) {\n  if (!arguments.length) return this._reconnection;\n  this._reconnection = !!v;\n  return this;\n};\n\n/**\n * Sets the reconnection attempts config.\n *\n * @param {Number} max reconnection attempts before giving up\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionAttempts = function (v) {\n  if (!arguments.length) return this._reconnectionAttempts;\n  this._reconnectionAttempts = v;\n  return this;\n};\n\n/**\n * Sets the delay between reconnections.\n *\n * @param {Number} delay\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionDelay = function (v) {\n  if (!arguments.length) return this._reconnectionDelay;\n  this._reconnectionDelay = v;\n  this.backoff && this.backoff.setMin(v);\n  return this;\n};\n\nManager.prototype.randomizationFactor = function (v) {\n  if (!arguments.length) return this._randomizationFactor;\n  this._randomizationFactor = v;\n  this.backoff && this.backoff.setJitter(v);\n  return this;\n};\n\n/**\n * Sets the maximum delay between reconnections.\n *\n * @param {Number} delay\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionDelayMax = function (v) {\n  if (!arguments.length) return this._reconnectionDelayMax;\n  this._reconnectionDelayMax = v;\n  this.backoff && this.backoff.setMax(v);\n  return this;\n};\n\n/**\n * Sets the connection timeout. `false` to disable\n *\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.timeout = function (v) {\n  if (!arguments.length) return this._timeout;\n  this._timeout = v;\n  return this;\n};\n\n/**\n * Starts trying to reconnect if reconnection is enabled and we have not\n * started reconnecting yet\n *\n * @api private\n */\n\nManager.prototype.maybeReconnectOnOpen = function () {\n  // Only try to reconnect if it's the first time we're connecting\n  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {\n    // keeps reconnection from firing twice for the same reconnection loop\n    this.reconnect();\n  }\n};\n\n/**\n * Sets the current transport `socket`.\n *\n * @param {Function} optional, callback\n * @return {Manager} self\n * @api public\n */\n\nManager.prototype.open =\nManager.prototype.connect = function (fn, opts) {\n  debug('readyState %s', this.readyState);\n  if (~this.readyState.indexOf('open')) return this;\n\n  debug('opening %s', this.uri);\n  this.engine = eio(this.uri, this.opts);\n  var socket = this.engine;\n  var self = this;\n  this.readyState = 'opening';\n  this.skipReconnect = false;\n\n  // emit `open`\n  var openSub = on(socket, 'open', function () {\n    self.onopen();\n    fn && fn();\n  });\n\n  // emit `connect_error`\n  var errorSub = on(socket, 'error', function (data) {\n    debug('connect_error');\n    self.cleanup();\n    self.readyState = 'closed';\n    self.emitAll('connect_error', data);\n    if (fn) {\n      var err = new Error('Connection error');\n      err.data = data;\n      fn(err);\n    } else {\n      // Only do this if there is no fn to handle the error\n      self.maybeReconnectOnOpen();\n    }\n  });\n\n  // emit `connect_timeout`\n  if (false !== this._timeout) {\n    var timeout = this._timeout;\n    debug('connect attempt will timeout after %d', timeout);\n\n    // set timer\n    var timer = setTimeout(function () {\n      debug('connect attempt timed out after %d', timeout);\n      openSub.destroy();\n      socket.close();\n      socket.emit('error', 'timeout');\n      self.emitAll('connect_timeout', timeout);\n    }, timeout);\n\n    this.subs.push({\n      destroy: function () {\n        clearTimeout(timer);\n      }\n    });\n  }\n\n  this.subs.push(openSub);\n  this.subs.push(errorSub);\n\n  return this;\n};\n\n/**\n * Called upon transport open.\n *\n * @api private\n */\n\nManager.prototype.onopen = function () {\n  debug('open');\n\n  // clear old subs\n  this.cleanup();\n\n  // mark as open\n  this.readyState = 'open';\n  this.emit('open');\n\n  // add new subs\n  var socket = this.engine;\n  this.subs.push(on(socket, 'data', bind(this, 'ondata')));\n  this.subs.push(on(socket, 'ping', bind(this, 'onping')));\n  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));\n  this.subs.push(on(socket, 'error', bind(this, 'onerror')));\n  this.subs.push(on(socket, 'close', bind(this, 'onclose')));\n  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));\n};\n\n/**\n * Called upon a ping.\n *\n * @api private\n */\n\nManager.prototype.onping = function () {\n  this.lastPing = new Date();\n  this.emitAll('ping');\n};\n\n/**\n * Called upon a packet.\n *\n * @api private\n */\n\nManager.prototype.onpong = function () {\n  this.emitAll('pong', new Date() - this.lastPing);\n};\n\n/**\n * Called with data.\n *\n * @api private\n */\n\nManager.prototype.ondata = function (data) {\n  this.decoder.add(data);\n};\n\n/**\n * Called when parser fully decodes a packet.\n *\n * @api private\n */\n\nManager.prototype.ondecoded = function (packet) {\n  this.emit('packet', packet);\n};\n\n/**\n * Called upon socket error.\n *\n * @api private\n */\n\nManager.prototype.onerror = function (err) {\n  debug('error', err);\n  this.emitAll('error', err);\n};\n\n/**\n * Creates a new socket for the given `nsp`.\n *\n * @return {Socket}\n * @api public\n */\n\nManager.prototype.socket = function (nsp, opts) {\n  var socket = this.nsps[nsp];\n  if (!socket) {\n    socket = new Socket(this, nsp, opts);\n    this.nsps[nsp] = socket;\n    var self = this;\n    socket.on('connecting', onConnecting);\n    socket.on('connect', function () {\n      socket.id = self.engine.id;\n    });\n\n    if (this.autoConnect) {\n      // manually call here since connecting evnet is fired before listening\n      onConnecting();\n    }\n  }\n\n  function onConnecting () {\n    if (!~indexOf(self.connecting, socket)) {\n      self.connecting.push(socket);\n    }\n  }\n\n  return socket;\n};\n\n/**\n * Called upon a socket close.\n *\n * @param {Socket} socket\n */\n\nManager.prototype.destroy = function (socket) {\n  var index = indexOf(this.connecting, socket);\n  if (~index) this.connecting.splice(index, 1);\n  if (this.connecting.length) return;\n\n  this.close();\n};\n\n/**\n * Writes a packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nManager.prototype.packet = function (packet) {\n  debug('writing packet %j', packet);\n  var self = this;\n  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;\n\n  if (!self.encoding) {\n    // encode, then write to engine with result\n    self.encoding = true;\n    this.encoder.encode(packet, function (encodedPackets) {\n      for (var i = 0; i < encodedPackets.length; i++) {\n        self.engine.write(encodedPackets[i], packet.options);\n      }\n      self.encoding = false;\n      self.processPacketQueue();\n    });\n  } else { // add packet to the queue\n    self.packetBuffer.push(packet);\n  }\n};\n\n/**\n * If packet buffer is non-empty, begins encoding the\n * next packet in line.\n *\n * @api private\n */\n\nManager.prototype.processPacketQueue = function () {\n  if (this.packetBuffer.length > 0 && !this.encoding) {\n    var pack = this.packetBuffer.shift();\n    this.packet(pack);\n  }\n};\n\n/**\n * Clean up transport subscriptions and packet buffer.\n *\n * @api private\n */\n\nManager.prototype.cleanup = function () {\n  debug('cleanup');\n\n  var subsLength = this.subs.length;\n  for (var i = 0; i < subsLength; i++) {\n    var sub = this.subs.shift();\n    sub.destroy();\n  }\n\n  this.packetBuffer = [];\n  this.encoding = false;\n  this.lastPing = null;\n\n  this.decoder.destroy();\n};\n\n/**\n * Close the current socket.\n *\n * @api private\n */\n\nManager.prototype.close =\nManager.prototype.disconnect = function () {\n  debug('disconnect');\n  this.skipReconnect = true;\n  this.reconnecting = false;\n  if ('opening' === this.readyState) {\n    // `onclose` will not fire because\n    // an open event never happened\n    this.cleanup();\n  }\n  this.backoff.reset();\n  this.readyState = 'closed';\n  if (this.engine) this.engine.close();\n};\n\n/**\n * Called upon engine close.\n *\n * @api private\n */\n\nManager.prototype.onclose = function (reason) {\n  debug('onclose');\n\n  this.cleanup();\n  this.backoff.reset();\n  this.readyState = 'closed';\n  this.emit('close', reason);\n\n  if (this._reconnection && !this.skipReconnect) {\n    this.reconnect();\n  }\n};\n\n/**\n * Attempt a reconnection.\n *\n * @api private\n */\n\nManager.prototype.reconnect = function () {\n  if (this.reconnecting || this.skipReconnect) return this;\n\n  var self = this;\n\n  if (this.backoff.attempts >= this._reconnectionAttempts) {\n    debug('reconnect failed');\n    this.backoff.reset();\n    this.emitAll('reconnect_failed');\n    this.reconnecting = false;\n  } else {\n    var delay = this.backoff.duration();\n    debug('will wait %dms before reconnect attempt', delay);\n\n    this.reconnecting = true;\n    var timer = setTimeout(function () {\n      if (self.skipReconnect) return;\n\n      debug('attempting reconnect');\n      self.emitAll('reconnect_attempt', self.backoff.attempts);\n      self.emitAll('reconnecting', self.backoff.attempts);\n\n      // check again for the case socket closed in above events\n      if (self.skipReconnect) return;\n\n      self.open(function (err) {\n        if (err) {\n          debug('reconnect attempt error');\n          self.reconnecting = false;\n          self.reconnect();\n          self.emitAll('reconnect_error', err.data);\n        } else {\n          debug('reconnect success');\n          self.onreconnect();\n        }\n      });\n    }, delay);\n\n    this.subs.push({\n      destroy: function () {\n        clearTimeout(timer);\n      }\n    });\n  }\n};\n\n/**\n * Called upon successful reconnect.\n *\n * @api private\n */\n\nManager.prototype.onreconnect = function () {\n  var attempt = this.backoff.attempts;\n  this.reconnecting = false;\n  this.backoff.reset();\n  this.updateSocketIds();\n  this.emitAll('reconnect', attempt);\n};\n"]},"metadata":{},"sourceType":"script"}