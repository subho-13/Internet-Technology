{"ast":null,"code":"/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\nvar util = require('util');\n/**\n * State constants\n */\n\n\nvar EMPTY = 0,\n    BODY = 1;\nvar BINARYLENGTH = 2,\n    BINARYBODY = 3;\n/**\n * Hixie Receiver implementation\n */\n\nfunction Receiver() {\n  if (this instanceof Receiver === false) {\n    throw new TypeError(\"Classes can't be function-called\");\n  }\n\n  this.state = EMPTY;\n  this.buffers = [];\n  this.messageEnd = -1;\n  this.spanLength = 0;\n  this.dead = false;\n\n  this.onerror = function () {};\n\n  this.ontext = function () {};\n\n  this.onbinary = function () {};\n\n  this.onclose = function () {};\n\n  this.onping = function () {};\n\n  this.onpong = function () {};\n}\n\nmodule.exports = Receiver;\n/**\n * Add new data to the parser.\n *\n * @api public\n */\n\nReceiver.prototype.add = function (data) {\n  if (this.dead) return;\n  var self = this;\n\n  function doAdd() {\n    if (self.state === EMPTY) {\n      if (data.length == 2 && data[0] == 0xFF && data[1] == 0x00) {\n        self.reset();\n        self.onclose();\n        return;\n      }\n\n      if (data[0] === 0x80) {\n        self.messageEnd = 0;\n        self.state = BINARYLENGTH;\n        data = data.slice(1);\n      } else {\n        if (data[0] !== 0x00) {\n          self.error('payload must start with 0x00 byte', true);\n          return;\n        }\n\n        data = data.slice(1);\n        self.state = BODY;\n      }\n    }\n\n    if (self.state === BINARYLENGTH) {\n      var i = 0;\n\n      while (i < data.length && data[i] & 0x80) {\n        self.messageEnd = 128 * self.messageEnd + (data[i] & 0x7f);\n        ++i;\n      }\n\n      if (i < data.length) {\n        self.messageEnd = 128 * self.messageEnd + (data[i] & 0x7f);\n        self.state = BINARYBODY;\n        ++i;\n      }\n\n      if (i > 0) data = data.slice(i);\n    }\n\n    if (self.state === BINARYBODY) {\n      var dataleft = self.messageEnd - self.spanLength;\n\n      if (data.length >= dataleft) {\n        // consume the whole buffer to finish the frame\n        self.buffers.push(data);\n        self.spanLength += dataleft;\n        self.messageEnd = dataleft;\n        return self.parse();\n      } // frame's not done even if we consume it all\n\n\n      self.buffers.push(data);\n      self.spanLength += data.length;\n      return;\n    }\n\n    self.buffers.push(data);\n\n    if ((self.messageEnd = bufferIndex(data, 0xFF)) != -1) {\n      self.spanLength += self.messageEnd;\n      return self.parse();\n    } else self.spanLength += data.length;\n  }\n\n  while (data) data = doAdd();\n};\n/**\n * Releases all resources used by the receiver.\n *\n * @api public\n */\n\n\nReceiver.prototype.cleanup = function () {\n  this.dead = true;\n  this.state = EMPTY;\n  this.buffers = [];\n};\n/**\n * Process buffered data.\n *\n * @api public\n */\n\n\nReceiver.prototype.parse = function () {\n  var output = new Buffer(this.spanLength);\n  var outputIndex = 0;\n\n  for (var bi = 0, bl = this.buffers.length; bi < bl - 1; ++bi) {\n    var buffer = this.buffers[bi];\n    buffer.copy(output, outputIndex);\n    outputIndex += buffer.length;\n  }\n\n  var lastBuffer = this.buffers[this.buffers.length - 1];\n  if (this.messageEnd > 0) lastBuffer.copy(output, outputIndex, 0, this.messageEnd);\n  if (this.state !== BODY) --this.messageEnd;\n  var tail = null;\n\n  if (this.messageEnd < lastBuffer.length - 1) {\n    tail = lastBuffer.slice(this.messageEnd + 1);\n  }\n\n  this.reset();\n  this.ontext(output.toString('utf8'));\n  return tail;\n};\n/**\n * Handles an error\n *\n * @api private\n */\n\n\nReceiver.prototype.error = function (reason, terminate) {\n  if (this.dead) return;\n  this.reset();\n\n  if (typeof reason == 'string') {\n    this.onerror(new Error(reason), terminate);\n  } else if (reason.constructor == Error) {\n    this.onerror(reason, terminate);\n  } else {\n    this.onerror(new Error(\"An error occured\"), terminate);\n  }\n\n  return this;\n};\n/**\n * Reset parser state\n *\n * @api private\n */\n\n\nReceiver.prototype.reset = function (reason) {\n  if (this.dead) return;\n  this.state = EMPTY;\n  this.buffers = [];\n  this.messageEnd = -1;\n  this.spanLength = 0;\n};\n/**\n * Internal api\n */\n\n\nfunction bufferIndex(buffer, byte) {\n  for (var i = 0, l = buffer.length; i < l; ++i) {\n    if (buffer[i] === byte) return i;\n  }\n\n  return -1;\n}","map":{"version":3,"sources":["/home/subho/Programming/Internet-Technology/Athena/node_modules/ws/lib/Receiver.hixie.js"],"names":["util","require","EMPTY","BODY","BINARYLENGTH","BINARYBODY","Receiver","TypeError","state","buffers","messageEnd","spanLength","dead","onerror","ontext","onbinary","onclose","onping","onpong","module","exports","prototype","add","data","self","doAdd","length","reset","slice","error","i","dataleft","push","parse","bufferIndex","cleanup","output","Buffer","outputIndex","bi","bl","buffer","copy","lastBuffer","tail","toString","reason","terminate","Error","constructor","byte","l"],"mappings":"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","sourcesContent":["/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nvar util = require('util');\n\n/**\n * State constants\n */\n\nvar EMPTY = 0\n  , BODY = 1;\nvar BINARYLENGTH = 2\n  , BINARYBODY = 3;\n\n/**\n * Hixie Receiver implementation\n */\n\nfunction Receiver () {\n  if (this instanceof Receiver === false) {\n    throw new TypeError(\"Classes can't be function-called\");\n  }\n\n  this.state = EMPTY;\n  this.buffers = [];\n  this.messageEnd = -1;\n  this.spanLength = 0;\n  this.dead = false;\n\n  this.onerror = function() {};\n  this.ontext = function() {};\n  this.onbinary = function() {};\n  this.onclose = function() {};\n  this.onping = function() {};\n  this.onpong = function() {};\n}\n\nmodule.exports = Receiver;\n\n/**\n * Add new data to the parser.\n *\n * @api public\n */\n\nReceiver.prototype.add = function(data) {\n  if (this.dead) return;\n  var self = this;\n  function doAdd() {\n    if (self.state === EMPTY) {\n      if (data.length == 2 && data[0] == 0xFF && data[1] == 0x00) {\n        self.reset();\n        self.onclose();\n        return;\n      }\n      if (data[0] === 0x80) {\n        self.messageEnd = 0;\n        self.state = BINARYLENGTH;\n        data = data.slice(1);\n      } else {\n\n      if (data[0] !== 0x00) {\n        self.error('payload must start with 0x00 byte', true);\n        return;\n      }\n      data = data.slice(1);\n      self.state = BODY;\n\n      }\n    }\n    if (self.state === BINARYLENGTH) {\n      var i = 0;\n      while ((i < data.length) && (data[i] & 0x80)) {\n        self.messageEnd = 128 * self.messageEnd + (data[i] & 0x7f);\n        ++i;\n      }\n      if (i < data.length) {\n        self.messageEnd = 128 * self.messageEnd + (data[i] & 0x7f);\n        self.state = BINARYBODY;\n        ++i;\n      }\n      if (i > 0)\n        data = data.slice(i);\n    }\n    if (self.state === BINARYBODY) {\n      var dataleft = self.messageEnd - self.spanLength;\n      if (data.length >= dataleft) {\n        // consume the whole buffer to finish the frame\n        self.buffers.push(data);\n        self.spanLength += dataleft;\n        self.messageEnd = dataleft;\n        return self.parse();\n      }\n      // frame's not done even if we consume it all\n      self.buffers.push(data);\n      self.spanLength += data.length;\n      return;\n    }\n    self.buffers.push(data);\n    if ((self.messageEnd = bufferIndex(data, 0xFF)) != -1) {\n      self.spanLength += self.messageEnd;\n      return self.parse();\n    }\n    else self.spanLength += data.length;\n  }\n  while(data) data = doAdd();\n};\n\n/**\n * Releases all resources used by the receiver.\n *\n * @api public\n */\n\nReceiver.prototype.cleanup = function() {\n  this.dead = true;\n  this.state = EMPTY;\n  this.buffers = [];\n};\n\n/**\n * Process buffered data.\n *\n * @api public\n */\n\nReceiver.prototype.parse = function() {\n  var output = new Buffer(this.spanLength);\n  var outputIndex = 0;\n  for (var bi = 0, bl = this.buffers.length; bi < bl - 1; ++bi) {\n    var buffer = this.buffers[bi];\n    buffer.copy(output, outputIndex);\n    outputIndex += buffer.length;\n  }\n  var lastBuffer = this.buffers[this.buffers.length - 1];\n  if (this.messageEnd > 0) lastBuffer.copy(output, outputIndex, 0, this.messageEnd);\n  if (this.state !== BODY) --this.messageEnd;\n  var tail = null;\n  if (this.messageEnd < lastBuffer.length - 1) {\n    tail = lastBuffer.slice(this.messageEnd + 1);\n  }\n  this.reset();\n  this.ontext(output.toString('utf8'));\n  return tail;\n};\n\n/**\n * Handles an error\n *\n * @api private\n */\n\nReceiver.prototype.error = function (reason, terminate) {\n  if (this.dead) return;\n  this.reset();\n  if(typeof reason == 'string'){\n    this.onerror(new Error(reason), terminate);\n  }\n  else if(reason.constructor == Error){\n    this.onerror(reason, terminate);\n  }\n  else{\n    this.onerror(new Error(\"An error occured\"),terminate);\n  }\n  return this;\n};\n\n/**\n * Reset parser state\n *\n * @api private\n */\n\nReceiver.prototype.reset = function (reason) {\n  if (this.dead) return;\n  this.state = EMPTY;\n  this.buffers = [];\n  this.messageEnd = -1;\n  this.spanLength = 0;\n};\n\n/**\n * Internal api\n */\n\nfunction bufferIndex(buffer, byte) {\n  for (var i = 0, l = buffer.length; i < l; ++i) {\n    if (buffer[i] === byte) return i;\n  }\n  return -1;\n}\n"]},"metadata":{},"sourceType":"script"}