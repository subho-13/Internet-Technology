{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar keys = require('./keys');\n\nvar hasBinary = require('has-binary');\n\nvar sliceBuffer = require('arraybuffer.slice');\n\nvar after = require('after');\n\nvar utf8 = require('wtf-8');\n\nvar base64encoder;\n\nif (global && global.ArrayBuffer) {\n  base64encoder = require('base64-arraybuffer');\n}\n/**\n * Check if we are running an android browser. That requires us to use\n * ArrayBuffer with polling transports...\n *\n * http://ghinda.net/jpeg-blob-ajax-android/\n */\n\n\nvar isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);\n/**\n * Check if we are running in PhantomJS.\n * Uploading a Blob with PhantomJS does not work correctly, as reported here:\n * https://github.com/ariya/phantomjs/issues/11395\n * @type boolean\n */\n\nvar isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);\n/**\n * When true, avoids using Blobs to encode payloads.\n * @type boolean\n */\n\nvar dontSendBlobs = isAndroid || isPhantomJS;\n/**\n * Current protocol version.\n */\n\nexports.protocol = 3;\n/**\n * Packet types.\n */\n\nvar packets = exports.packets = {\n  open: 0 // non-ws\n  ,\n  close: 1 // non-ws\n  ,\n  ping: 2,\n  pong: 3,\n  message: 4,\n  upgrade: 5,\n  noop: 6\n};\nvar packetslist = keys(packets);\n/**\n * Premade error packet.\n */\n\nvar err = {\n  type: 'error',\n  data: 'parser error'\n};\n/**\n * Create a blob api even for blob builder when vendor prefixes exist\n */\n\nvar Blob = require('blob');\n/**\n * Encodes a packet.\n *\n *     <packet type id> [ <data> ]\n *\n * Example:\n *\n *     5hello world\n *     3\n *     4\n *\n * Binary is encoded in an identical principle\n *\n * @api private\n */\n\n\nexports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {\n  if ('function' == typeof supportsBinary) {\n    callback = supportsBinary;\n    supportsBinary = false;\n  }\n\n  if ('function' == typeof utf8encode) {\n    callback = utf8encode;\n    utf8encode = null;\n  }\n\n  var data = packet.data === undefined ? undefined : packet.data.buffer || packet.data;\n\n  if (global.ArrayBuffer && data instanceof ArrayBuffer) {\n    return encodeArrayBuffer(packet, supportsBinary, callback);\n  } else if (Blob && data instanceof global.Blob) {\n    return encodeBlob(packet, supportsBinary, callback);\n  } // might be an object with { base64: true, data: dataAsBase64String }\n\n\n  if (data && data.base64) {\n    return encodeBase64Object(packet, callback);\n  } // Sending data as a utf-8 string\n\n\n  var encoded = packets[packet.type]; // data fragment is optional\n\n  if (undefined !== packet.data) {\n    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);\n  }\n\n  return callback('' + encoded);\n};\n\nfunction encodeBase64Object(packet, callback) {\n  // packet data is an object { base64: true, data: dataAsBase64String }\n  var message = 'b' + exports.packets[packet.type] + packet.data.data;\n  return callback(message);\n}\n/**\n * Encode packet helpers for binary types\n */\n\n\nfunction encodeArrayBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  var data = packet.data;\n  var contentArray = new Uint8Array(data);\n  var resultBuffer = new Uint8Array(1 + data.byteLength);\n  resultBuffer[0] = packets[packet.type];\n\n  for (var i = 0; i < contentArray.length; i++) {\n    resultBuffer[i + 1] = contentArray[i];\n  }\n\n  return callback(resultBuffer.buffer);\n}\n\nfunction encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  var fr = new FileReader();\n\n  fr.onload = function () {\n    packet.data = fr.result;\n    exports.encodePacket(packet, supportsBinary, true, callback);\n  };\n\n  return fr.readAsArrayBuffer(packet.data);\n}\n\nfunction encodeBlob(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  if (dontSendBlobs) {\n    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);\n  }\n\n  var length = new Uint8Array(1);\n  length[0] = packets[packet.type];\n  var blob = new Blob([length.buffer, packet.data]);\n  return callback(blob);\n}\n/**\n * Encodes a packet with binary data in a base64 string\n *\n * @param {Object} packet, has `type` and `data`\n * @return {String} base64 encoded message\n */\n\n\nexports.encodeBase64Packet = function (packet, callback) {\n  var message = 'b' + exports.packets[packet.type];\n\n  if (Blob && packet.data instanceof global.Blob) {\n    var fr = new FileReader();\n\n    fr.onload = function () {\n      var b64 = fr.result.split(',')[1];\n      callback(message + b64);\n    };\n\n    return fr.readAsDataURL(packet.data);\n  }\n\n  var b64data;\n\n  try {\n    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));\n  } catch (e) {\n    // iPhone Safari doesn't let you apply with typed arrays\n    var typed = new Uint8Array(packet.data);\n    var basic = new Array(typed.length);\n\n    for (var i = 0; i < typed.length; i++) {\n      basic[i] = typed[i];\n    }\n\n    b64data = String.fromCharCode.apply(null, basic);\n  }\n\n  message += global.btoa(b64data);\n  return callback(message);\n};\n/**\n * Decodes a packet. Changes format to Blob if requested.\n *\n * @return {Object} with `type` and `data` (if any)\n * @api private\n */\n\n\nexports.decodePacket = function (data, binaryType, utf8decode) {\n  if (data === undefined) {\n    return err;\n  } // String data\n\n\n  if (typeof data == 'string') {\n    if (data.charAt(0) == 'b') {\n      return exports.decodeBase64Packet(data.substr(1), binaryType);\n    }\n\n    if (utf8decode) {\n      data = tryDecode(data);\n\n      if (data === false) {\n        return err;\n      }\n    }\n\n    var type = data.charAt(0);\n\n    if (Number(type) != type || !packetslist[type]) {\n      return err;\n    }\n\n    if (data.length > 1) {\n      return {\n        type: packetslist[type],\n        data: data.substring(1)\n      };\n    } else {\n      return {\n        type: packetslist[type]\n      };\n    }\n  }\n\n  var asArray = new Uint8Array(data);\n  var type = asArray[0];\n  var rest = sliceBuffer(data, 1);\n\n  if (Blob && binaryType === 'blob') {\n    rest = new Blob([rest]);\n  }\n\n  return {\n    type: packetslist[type],\n    data: rest\n  };\n};\n\nfunction tryDecode(data) {\n  try {\n    data = utf8.decode(data);\n  } catch (e) {\n    return false;\n  }\n\n  return data;\n}\n/**\n * Decodes a packet encoded in a base64 string\n *\n * @param {String} base64 encoded message\n * @return {Object} with `type` and `data` (if any)\n */\n\n\nexports.decodeBase64Packet = function (msg, binaryType) {\n  var type = packetslist[msg.charAt(0)];\n\n  if (!base64encoder) {\n    return {\n      type: type,\n      data: {\n        base64: true,\n        data: msg.substr(1)\n      }\n    };\n  }\n\n  var data = base64encoder.decode(msg.substr(1));\n\n  if (binaryType === 'blob' && Blob) {\n    data = new Blob([data]);\n  }\n\n  return {\n    type: type,\n    data: data\n  };\n};\n/**\n * Encodes multiple messages (payload).\n *\n *     <length>:data\n *\n * Example:\n *\n *     11:hello world2:hi\n *\n * If any contents are binary, they will be encoded as base64 strings. Base64\n * encoded strings are marked with a b before the length specifier\n *\n * @param {Array} packets\n * @api private\n */\n\n\nexports.encodePayload = function (packets, supportsBinary, callback) {\n  if (typeof supportsBinary == 'function') {\n    callback = supportsBinary;\n    supportsBinary = null;\n  }\n\n  var isBinary = hasBinary(packets);\n\n  if (supportsBinary && isBinary) {\n    if (Blob && !dontSendBlobs) {\n      return exports.encodePayloadAsBlob(packets, callback);\n    }\n\n    return exports.encodePayloadAsArrayBuffer(packets, callback);\n  }\n\n  if (!packets.length) {\n    return callback('0:');\n  }\n\n  function setLengthHeader(message) {\n    return message.length + ':' + message;\n  }\n\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function (message) {\n      doneCallback(null, setLengthHeader(message));\n    });\n  }\n\n  map(packets, encodeOne, function (err, results) {\n    return callback(results.join(''));\n  });\n};\n/**\n * Async array map using after\n */\n\n\nfunction map(ary, each, done) {\n  var result = new Array(ary.length);\n  var next = after(ary.length, done);\n\n  var eachWithIndex = function (i, el, cb) {\n    each(el, function (error, msg) {\n      result[i] = msg;\n      cb(error, result);\n    });\n  };\n\n  for (var i = 0; i < ary.length; i++) {\n    eachWithIndex(i, ary[i], next);\n  }\n}\n/*\n * Decodes data when a payload is maybe expected. Possible binary contents are\n * decoded from their base64 representation\n *\n * @param {String} data, callback method\n * @api public\n */\n\n\nexports.decodePayload = function (data, binaryType, callback) {\n  if (typeof data != 'string') {\n    return exports.decodePayloadAsBinary(data, binaryType, callback);\n  }\n\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  var packet;\n\n  if (data == '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n  var length = '',\n      n,\n      msg;\n\n  for (var i = 0, l = data.length; i < l; i++) {\n    var chr = data.charAt(i);\n\n    if (':' != chr) {\n      length += chr;\n    } else {\n      if ('' == length || length != (n = Number(length))) {\n        // parser error - ignoring payload\n        return callback(err, 0, 1);\n      }\n\n      msg = data.substr(i + 1, n);\n\n      if (length != msg.length) {\n        // parser error - ignoring payload\n        return callback(err, 0, 1);\n      }\n\n      if (msg.length) {\n        packet = exports.decodePacket(msg, binaryType, true);\n\n        if (err.type == packet.type && err.data == packet.data) {\n          // parser error in individual packet - ignoring payload\n          return callback(err, 0, 1);\n        }\n\n        var ret = callback(packet, i + n, l);\n        if (false === ret) return;\n      } // advance cursor\n\n\n      i += n;\n      length = '';\n    }\n  }\n\n  if (length != '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n};\n/**\n * Encodes multiple messages (payload) as binary.\n *\n * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number\n * 255><data>\n *\n * Example:\n * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers\n *\n * @param {Array} packets\n * @return {ArrayBuffer} encoded payload\n * @api private\n */\n\n\nexports.encodePayloadAsArrayBuffer = function (packets, callback) {\n  if (!packets.length) {\n    return callback(new ArrayBuffer(0));\n  }\n\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, true, true, function (data) {\n      return doneCallback(null, data);\n    });\n  }\n\n  map(packets, encodeOne, function (err, encodedPackets) {\n    var totalLength = encodedPackets.reduce(function (acc, p) {\n      var len;\n\n      if (typeof p === 'string') {\n        len = p.length;\n      } else {\n        len = p.byteLength;\n      }\n\n      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2\n    }, 0);\n    var resultArray = new Uint8Array(totalLength);\n    var bufferIndex = 0;\n    encodedPackets.forEach(function (p) {\n      var isString = typeof p === 'string';\n      var ab = p;\n\n      if (isString) {\n        var view = new Uint8Array(p.length);\n\n        for (var i = 0; i < p.length; i++) {\n          view[i] = p.charCodeAt(i);\n        }\n\n        ab = view.buffer;\n      }\n\n      if (isString) {\n        // not true binary\n        resultArray[bufferIndex++] = 0;\n      } else {\n        // true binary\n        resultArray[bufferIndex++] = 1;\n      }\n\n      var lenStr = ab.byteLength.toString();\n\n      for (var i = 0; i < lenStr.length; i++) {\n        resultArray[bufferIndex++] = parseInt(lenStr[i]);\n      }\n\n      resultArray[bufferIndex++] = 255;\n      var view = new Uint8Array(ab);\n\n      for (var i = 0; i < view.length; i++) {\n        resultArray[bufferIndex++] = view[i];\n      }\n    });\n    return callback(resultArray.buffer);\n  });\n};\n/**\n * Encode as Blob\n */\n\n\nexports.encodePayloadAsBlob = function (packets, callback) {\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, true, true, function (encoded) {\n      var binaryIdentifier = new Uint8Array(1);\n      binaryIdentifier[0] = 1;\n\n      if (typeof encoded === 'string') {\n        var view = new Uint8Array(encoded.length);\n\n        for (var i = 0; i < encoded.length; i++) {\n          view[i] = encoded.charCodeAt(i);\n        }\n\n        encoded = view.buffer;\n        binaryIdentifier[0] = 0;\n      }\n\n      var len = encoded instanceof ArrayBuffer ? encoded.byteLength : encoded.size;\n      var lenStr = len.toString();\n      var lengthAry = new Uint8Array(lenStr.length + 1);\n\n      for (var i = 0; i < lenStr.length; i++) {\n        lengthAry[i] = parseInt(lenStr[i]);\n      }\n\n      lengthAry[lenStr.length] = 255;\n\n      if (Blob) {\n        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);\n        doneCallback(null, blob);\n      }\n    });\n  }\n\n  map(packets, encodeOne, function (err, results) {\n    return callback(new Blob(results));\n  });\n};\n/*\n * Decodes data when a payload is maybe expected. Strings are decoded by\n * interpreting each byte as a key code for entries marked to start with 0. See\n * description of encodePayloadAsBinary\n *\n * @param {ArrayBuffer} data, callback method\n * @api public\n */\n\n\nexports.decodePayloadAsBinary = function (data, binaryType, callback) {\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  var bufferTail = data;\n  var buffers = [];\n  var numberTooLong = false;\n\n  while (bufferTail.byteLength > 0) {\n    var tailArray = new Uint8Array(bufferTail);\n    var isString = tailArray[0] === 0;\n    var msgLength = '';\n\n    for (var i = 1;; i++) {\n      if (tailArray[i] == 255) break;\n\n      if (msgLength.length > 310) {\n        numberTooLong = true;\n        break;\n      }\n\n      msgLength += tailArray[i];\n    }\n\n    if (numberTooLong) return callback(err, 0, 1);\n    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);\n    msgLength = parseInt(msgLength);\n    var msg = sliceBuffer(bufferTail, 0, msgLength);\n\n    if (isString) {\n      try {\n        msg = String.fromCharCode.apply(null, new Uint8Array(msg));\n      } catch (e) {\n        // iPhone Safari doesn't let you apply to typed arrays\n        var typed = new Uint8Array(msg);\n        msg = '';\n\n        for (var i = 0; i < typed.length; i++) {\n          msg += String.fromCharCode(typed[i]);\n        }\n      }\n    }\n\n    buffers.push(msg);\n    bufferTail = sliceBuffer(bufferTail, msgLength);\n  }\n\n  var total = buffers.length;\n  buffers.forEach(function (buffer, i) {\n    callback(exports.decodePacket(buffer, binaryType, true), i, total);\n  });\n};","map":{"version":3,"sources":["/home/subho/Programming/Internet-Technology/Athena/node_modules/engine.io-parser/lib/browser.js"],"names":["keys","require","hasBinary","sliceBuffer","after","utf8","base64encoder","global","ArrayBuffer","isAndroid","navigator","test","userAgent","isPhantomJS","dontSendBlobs","exports","protocol","packets","open","close","ping","pong","message","upgrade","noop","packetslist","err","type","data","Blob","encodePacket","packet","supportsBinary","utf8encode","callback","undefined","buffer","encodeArrayBuffer","encodeBlob","base64","encodeBase64Object","encoded","encode","String","encodeBase64Packet","contentArray","Uint8Array","resultBuffer","byteLength","i","length","encodeBlobAsArrayBuffer","fr","FileReader","onload","result","readAsArrayBuffer","blob","b64","split","readAsDataURL","b64data","fromCharCode","apply","e","typed","basic","Array","btoa","decodePacket","binaryType","utf8decode","charAt","decodeBase64Packet","substr","tryDecode","Number","substring","asArray","rest","decode","msg","encodePayload","isBinary","encodePayloadAsBlob","encodePayloadAsArrayBuffer","setLengthHeader","encodeOne","doneCallback","map","results","join","ary","each","done","next","eachWithIndex","el","cb","error","decodePayload","decodePayloadAsBinary","n","l","chr","ret","encodedPackets","totalLength","reduce","acc","p","len","toString","resultArray","bufferIndex","forEach","isString","ab","view","charCodeAt","lenStr","parseInt","binaryIdentifier","size","lengthAry","bufferTail","buffers","numberTooLong","tailArray","msgLength","push","total"],"mappings":"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","sourcesContent":["/**\n * Module dependencies.\n */\n\nvar keys = require('./keys');\nvar hasBinary = require('has-binary');\nvar sliceBuffer = require('arraybuffer.slice');\nvar after = require('after');\nvar utf8 = require('wtf-8');\n\nvar base64encoder;\nif (global && global.ArrayBuffer) {\n  base64encoder = require('base64-arraybuffer');\n}\n\n/**\n * Check if we are running an android browser. That requires us to use\n * ArrayBuffer with polling transports...\n *\n * http://ghinda.net/jpeg-blob-ajax-android/\n */\n\nvar isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);\n\n/**\n * Check if we are running in PhantomJS.\n * Uploading a Blob with PhantomJS does not work correctly, as reported here:\n * https://github.com/ariya/phantomjs/issues/11395\n * @type boolean\n */\nvar isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);\n\n/**\n * When true, avoids using Blobs to encode payloads.\n * @type boolean\n */\nvar dontSendBlobs = isAndroid || isPhantomJS;\n\n/**\n * Current protocol version.\n */\n\nexports.protocol = 3;\n\n/**\n * Packet types.\n */\n\nvar packets = exports.packets = {\n    open:     0    // non-ws\n  , close:    1    // non-ws\n  , ping:     2\n  , pong:     3\n  , message:  4\n  , upgrade:  5\n  , noop:     6\n};\n\nvar packetslist = keys(packets);\n\n/**\n * Premade error packet.\n */\n\nvar err = { type: 'error', data: 'parser error' };\n\n/**\n * Create a blob api even for blob builder when vendor prefixes exist\n */\n\nvar Blob = require('blob');\n\n/**\n * Encodes a packet.\n *\n *     <packet type id> [ <data> ]\n *\n * Example:\n *\n *     5hello world\n *     3\n *     4\n *\n * Binary is encoded in an identical principle\n *\n * @api private\n */\n\nexports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {\n  if ('function' == typeof supportsBinary) {\n    callback = supportsBinary;\n    supportsBinary = false;\n  }\n\n  if ('function' == typeof utf8encode) {\n    callback = utf8encode;\n    utf8encode = null;\n  }\n\n  var data = (packet.data === undefined)\n    ? undefined\n    : packet.data.buffer || packet.data;\n\n  if (global.ArrayBuffer && data instanceof ArrayBuffer) {\n    return encodeArrayBuffer(packet, supportsBinary, callback);\n  } else if (Blob && data instanceof global.Blob) {\n    return encodeBlob(packet, supportsBinary, callback);\n  }\n\n  // might be an object with { base64: true, data: dataAsBase64String }\n  if (data && data.base64) {\n    return encodeBase64Object(packet, callback);\n  }\n\n  // Sending data as a utf-8 string\n  var encoded = packets[packet.type];\n\n  // data fragment is optional\n  if (undefined !== packet.data) {\n    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);\n  }\n\n  return callback('' + encoded);\n\n};\n\nfunction encodeBase64Object(packet, callback) {\n  // packet data is an object { base64: true, data: dataAsBase64String }\n  var message = 'b' + exports.packets[packet.type] + packet.data.data;\n  return callback(message);\n}\n\n/**\n * Encode packet helpers for binary types\n */\n\nfunction encodeArrayBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  var data = packet.data;\n  var contentArray = new Uint8Array(data);\n  var resultBuffer = new Uint8Array(1 + data.byteLength);\n\n  resultBuffer[0] = packets[packet.type];\n  for (var i = 0; i < contentArray.length; i++) {\n    resultBuffer[i+1] = contentArray[i];\n  }\n\n  return callback(resultBuffer.buffer);\n}\n\nfunction encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  var fr = new FileReader();\n  fr.onload = function() {\n    packet.data = fr.result;\n    exports.encodePacket(packet, supportsBinary, true, callback);\n  };\n  return fr.readAsArrayBuffer(packet.data);\n}\n\nfunction encodeBlob(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  if (dontSendBlobs) {\n    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);\n  }\n\n  var length = new Uint8Array(1);\n  length[0] = packets[packet.type];\n  var blob = new Blob([length.buffer, packet.data]);\n\n  return callback(blob);\n}\n\n/**\n * Encodes a packet with binary data in a base64 string\n *\n * @param {Object} packet, has `type` and `data`\n * @return {String} base64 encoded message\n */\n\nexports.encodeBase64Packet = function(packet, callback) {\n  var message = 'b' + exports.packets[packet.type];\n  if (Blob && packet.data instanceof global.Blob) {\n    var fr = new FileReader();\n    fr.onload = function() {\n      var b64 = fr.result.split(',')[1];\n      callback(message + b64);\n    };\n    return fr.readAsDataURL(packet.data);\n  }\n\n  var b64data;\n  try {\n    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));\n  } catch (e) {\n    // iPhone Safari doesn't let you apply with typed arrays\n    var typed = new Uint8Array(packet.data);\n    var basic = new Array(typed.length);\n    for (var i = 0; i < typed.length; i++) {\n      basic[i] = typed[i];\n    }\n    b64data = String.fromCharCode.apply(null, basic);\n  }\n  message += global.btoa(b64data);\n  return callback(message);\n};\n\n/**\n * Decodes a packet. Changes format to Blob if requested.\n *\n * @return {Object} with `type` and `data` (if any)\n * @api private\n */\n\nexports.decodePacket = function (data, binaryType, utf8decode) {\n  if (data === undefined) {\n    return err;\n  }\n  // String data\n  if (typeof data == 'string') {\n    if (data.charAt(0) == 'b') {\n      return exports.decodeBase64Packet(data.substr(1), binaryType);\n    }\n\n    if (utf8decode) {\n      data = tryDecode(data);\n      if (data === false) {\n        return err;\n      }\n    }\n    var type = data.charAt(0);\n\n    if (Number(type) != type || !packetslist[type]) {\n      return err;\n    }\n\n    if (data.length > 1) {\n      return { type: packetslist[type], data: data.substring(1) };\n    } else {\n      return { type: packetslist[type] };\n    }\n  }\n\n  var asArray = new Uint8Array(data);\n  var type = asArray[0];\n  var rest = sliceBuffer(data, 1);\n  if (Blob && binaryType === 'blob') {\n    rest = new Blob([rest]);\n  }\n  return { type: packetslist[type], data: rest };\n};\n\nfunction tryDecode(data) {\n  try {\n    data = utf8.decode(data);\n  } catch (e) {\n    return false;\n  }\n  return data;\n}\n\n/**\n * Decodes a packet encoded in a base64 string\n *\n * @param {String} base64 encoded message\n * @return {Object} with `type` and `data` (if any)\n */\n\nexports.decodeBase64Packet = function(msg, binaryType) {\n  var type = packetslist[msg.charAt(0)];\n  if (!base64encoder) {\n    return { type: type, data: { base64: true, data: msg.substr(1) } };\n  }\n\n  var data = base64encoder.decode(msg.substr(1));\n\n  if (binaryType === 'blob' && Blob) {\n    data = new Blob([data]);\n  }\n\n  return { type: type, data: data };\n};\n\n/**\n * Encodes multiple messages (payload).\n *\n *     <length>:data\n *\n * Example:\n *\n *     11:hello world2:hi\n *\n * If any contents are binary, they will be encoded as base64 strings. Base64\n * encoded strings are marked with a b before the length specifier\n *\n * @param {Array} packets\n * @api private\n */\n\nexports.encodePayload = function (packets, supportsBinary, callback) {\n  if (typeof supportsBinary == 'function') {\n    callback = supportsBinary;\n    supportsBinary = null;\n  }\n\n  var isBinary = hasBinary(packets);\n\n  if (supportsBinary && isBinary) {\n    if (Blob && !dontSendBlobs) {\n      return exports.encodePayloadAsBlob(packets, callback);\n    }\n\n    return exports.encodePayloadAsArrayBuffer(packets, callback);\n  }\n\n  if (!packets.length) {\n    return callback('0:');\n  }\n\n  function setLengthHeader(message) {\n    return message.length + ':' + message;\n  }\n\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {\n      doneCallback(null, setLengthHeader(message));\n    });\n  }\n\n  map(packets, encodeOne, function(err, results) {\n    return callback(results.join(''));\n  });\n};\n\n/**\n * Async array map using after\n */\n\nfunction map(ary, each, done) {\n  var result = new Array(ary.length);\n  var next = after(ary.length, done);\n\n  var eachWithIndex = function(i, el, cb) {\n    each(el, function(error, msg) {\n      result[i] = msg;\n      cb(error, result);\n    });\n  };\n\n  for (var i = 0; i < ary.length; i++) {\n    eachWithIndex(i, ary[i], next);\n  }\n}\n\n/*\n * Decodes data when a payload is maybe expected. Possible binary contents are\n * decoded from their base64 representation\n *\n * @param {String} data, callback method\n * @api public\n */\n\nexports.decodePayload = function (data, binaryType, callback) {\n  if (typeof data != 'string') {\n    return exports.decodePayloadAsBinary(data, binaryType, callback);\n  }\n\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  var packet;\n  if (data == '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n  var length = ''\n    , n, msg;\n\n  for (var i = 0, l = data.length; i < l; i++) {\n    var chr = data.charAt(i);\n\n    if (':' != chr) {\n      length += chr;\n    } else {\n      if ('' == length || (length != (n = Number(length)))) {\n        // parser error - ignoring payload\n        return callback(err, 0, 1);\n      }\n\n      msg = data.substr(i + 1, n);\n\n      if (length != msg.length) {\n        // parser error - ignoring payload\n        return callback(err, 0, 1);\n      }\n\n      if (msg.length) {\n        packet = exports.decodePacket(msg, binaryType, true);\n\n        if (err.type == packet.type && err.data == packet.data) {\n          // parser error in individual packet - ignoring payload\n          return callback(err, 0, 1);\n        }\n\n        var ret = callback(packet, i + n, l);\n        if (false === ret) return;\n      }\n\n      // advance cursor\n      i += n;\n      length = '';\n    }\n  }\n\n  if (length != '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n};\n\n/**\n * Encodes multiple messages (payload) as binary.\n *\n * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number\n * 255><data>\n *\n * Example:\n * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers\n *\n * @param {Array} packets\n * @return {ArrayBuffer} encoded payload\n * @api private\n */\n\nexports.encodePayloadAsArrayBuffer = function(packets, callback) {\n  if (!packets.length) {\n    return callback(new ArrayBuffer(0));\n  }\n\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, true, true, function(data) {\n      return doneCallback(null, data);\n    });\n  }\n\n  map(packets, encodeOne, function(err, encodedPackets) {\n    var totalLength = encodedPackets.reduce(function(acc, p) {\n      var len;\n      if (typeof p === 'string'){\n        len = p.length;\n      } else {\n        len = p.byteLength;\n      }\n      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2\n    }, 0);\n\n    var resultArray = new Uint8Array(totalLength);\n\n    var bufferIndex = 0;\n    encodedPackets.forEach(function(p) {\n      var isString = typeof p === 'string';\n      var ab = p;\n      if (isString) {\n        var view = new Uint8Array(p.length);\n        for (var i = 0; i < p.length; i++) {\n          view[i] = p.charCodeAt(i);\n        }\n        ab = view.buffer;\n      }\n\n      if (isString) { // not true binary\n        resultArray[bufferIndex++] = 0;\n      } else { // true binary\n        resultArray[bufferIndex++] = 1;\n      }\n\n      var lenStr = ab.byteLength.toString();\n      for (var i = 0; i < lenStr.length; i++) {\n        resultArray[bufferIndex++] = parseInt(lenStr[i]);\n      }\n      resultArray[bufferIndex++] = 255;\n\n      var view = new Uint8Array(ab);\n      for (var i = 0; i < view.length; i++) {\n        resultArray[bufferIndex++] = view[i];\n      }\n    });\n\n    return callback(resultArray.buffer);\n  });\n};\n\n/**\n * Encode as Blob\n */\n\nexports.encodePayloadAsBlob = function(packets, callback) {\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, true, true, function(encoded) {\n      var binaryIdentifier = new Uint8Array(1);\n      binaryIdentifier[0] = 1;\n      if (typeof encoded === 'string') {\n        var view = new Uint8Array(encoded.length);\n        for (var i = 0; i < encoded.length; i++) {\n          view[i] = encoded.charCodeAt(i);\n        }\n        encoded = view.buffer;\n        binaryIdentifier[0] = 0;\n      }\n\n      var len = (encoded instanceof ArrayBuffer)\n        ? encoded.byteLength\n        : encoded.size;\n\n      var lenStr = len.toString();\n      var lengthAry = new Uint8Array(lenStr.length + 1);\n      for (var i = 0; i < lenStr.length; i++) {\n        lengthAry[i] = parseInt(lenStr[i]);\n      }\n      lengthAry[lenStr.length] = 255;\n\n      if (Blob) {\n        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);\n        doneCallback(null, blob);\n      }\n    });\n  }\n\n  map(packets, encodeOne, function(err, results) {\n    return callback(new Blob(results));\n  });\n};\n\n/*\n * Decodes data when a payload is maybe expected. Strings are decoded by\n * interpreting each byte as a key code for entries marked to start with 0. See\n * description of encodePayloadAsBinary\n *\n * @param {ArrayBuffer} data, callback method\n * @api public\n */\n\nexports.decodePayloadAsBinary = function (data, binaryType, callback) {\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  var bufferTail = data;\n  var buffers = [];\n\n  var numberTooLong = false;\n  while (bufferTail.byteLength > 0) {\n    var tailArray = new Uint8Array(bufferTail);\n    var isString = tailArray[0] === 0;\n    var msgLength = '';\n\n    for (var i = 1; ; i++) {\n      if (tailArray[i] == 255) break;\n\n      if (msgLength.length > 310) {\n        numberTooLong = true;\n        break;\n      }\n\n      msgLength += tailArray[i];\n    }\n\n    if(numberTooLong) return callback(err, 0, 1);\n\n    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);\n    msgLength = parseInt(msgLength);\n\n    var msg = sliceBuffer(bufferTail, 0, msgLength);\n    if (isString) {\n      try {\n        msg = String.fromCharCode.apply(null, new Uint8Array(msg));\n      } catch (e) {\n        // iPhone Safari doesn't let you apply to typed arrays\n        var typed = new Uint8Array(msg);\n        msg = '';\n        for (var i = 0; i < typed.length; i++) {\n          msg += String.fromCharCode(typed[i]);\n        }\n      }\n    }\n\n    buffers.push(msg);\n    bufferTail = sliceBuffer(bufferTail, msgLength);\n  }\n\n  var total = buffers.length;\n  buffers.forEach(function(buffer, i) {\n    callback(exports.decodePacket(buffer, binaryType, true), i, total);\n  });\n};\n"]},"metadata":{},"sourceType":"script"}