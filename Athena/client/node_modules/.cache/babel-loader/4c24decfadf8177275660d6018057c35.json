{"ast":null,"code":"/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\nvar util = require('util'),\n    events = require('events'),\n    http = require('http'),\n    crypto = require('crypto'),\n    Options = require('options'),\n    WebSocket = require('./WebSocket'),\n    Extensions = require('./Extensions'),\n    PerMessageDeflate = require('./PerMessageDeflate'),\n    tls = require('tls'),\n    url = require('url');\n/**\n * WebSocket Server implementation\n */\n\n\nfunction WebSocketServer(options, callback) {\n  if (this instanceof WebSocketServer === false) {\n    return new WebSocketServer(options, callback);\n  }\n\n  events.EventEmitter.call(this);\n  options = new Options({\n    host: '0.0.0.0',\n    port: null,\n    server: null,\n    verifyClient: null,\n    handleProtocols: null,\n    path: null,\n    noServer: false,\n    disableHixie: false,\n    clientTracking: true,\n    perMessageDeflate: true,\n    maxPayload: 100 * 1024 * 1024\n  }).merge(options);\n\n  if (!options.isDefinedAndNonNull('port') && !options.isDefinedAndNonNull('server') && !options.value.noServer) {\n    throw new TypeError('`port` or a `server` must be provided');\n  }\n\n  var self = this;\n\n  if (options.isDefinedAndNonNull('port')) {\n    this._server = http.createServer(function (req, res) {\n      var body = http.STATUS_CODES[426];\n      res.writeHead(426, {\n        'Content-Length': body.length,\n        'Content-Type': 'text/plain'\n      });\n      res.end(body);\n    });\n    this._server.allowHalfOpen = false;\n\n    this._server.listen(options.value.port, options.value.host, callback);\n\n    this._closeServer = function () {\n      if (self._server) self._server.close();\n    };\n  } else if (options.value.server) {\n    this._server = options.value.server;\n\n    if (options.value.path) {\n      // take note of the path, to avoid collisions when multiple websocket servers are\n      // listening on the same http server\n      if (this._server._webSocketPaths && options.value.server._webSocketPaths[options.value.path]) {\n        throw new Error('two instances of WebSocketServer cannot listen on the same http server path');\n      }\n\n      if (typeof this._server._webSocketPaths !== 'object') {\n        this._server._webSocketPaths = {};\n      }\n\n      this._server._webSocketPaths[options.value.path] = 1;\n    }\n  }\n\n  if (this._server) {\n    this._onceServerListening = function () {\n      self.emit('listening');\n    };\n\n    this._server.once('listening', this._onceServerListening);\n  }\n\n  if (typeof this._server != 'undefined') {\n    this._onServerError = function (error) {\n      self.emit('error', error);\n    };\n\n    this._server.on('error', this._onServerError);\n\n    this._onServerUpgrade = function (req, socket, upgradeHead) {\n      //copy upgradeHead to avoid retention of large slab buffers used in node core\n      var head = new Buffer(upgradeHead.length);\n      upgradeHead.copy(head);\n      self.handleUpgrade(req, socket, head, function (client) {\n        self.emit('connection' + req.url, client);\n        self.emit('connection', client);\n      });\n    };\n\n    this._server.on('upgrade', this._onServerUpgrade);\n  }\n\n  this.options = options.value;\n  this.path = options.value.path;\n  this.clients = [];\n}\n/**\n * Inherits from EventEmitter.\n */\n\n\nutil.inherits(WebSocketServer, events.EventEmitter);\n/**\n * Immediately shuts down the connection.\n *\n * @api public\n */\n\nWebSocketServer.prototype.close = function (callback) {\n  // terminate all associated clients\n  var error = null;\n\n  try {\n    for (var i = 0, l = this.clients.length; i < l; ++i) {\n      this.clients[i].terminate();\n    }\n  } catch (e) {\n    error = e;\n  } // remove path descriptor, if any\n\n\n  if (this.path && this._server._webSocketPaths) {\n    delete this._server._webSocketPaths[this.path];\n\n    if (Object.keys(this._server._webSocketPaths).length == 0) {\n      delete this._server._webSocketPaths;\n    }\n  } // close the http server if it was internally created\n\n\n  try {\n    if (typeof this._closeServer !== 'undefined') {\n      this._closeServer();\n    }\n  } finally {\n    if (this._server) {\n      this._server.removeListener('listening', this._onceServerListening);\n\n      this._server.removeListener('error', this._onServerError);\n\n      this._server.removeListener('upgrade', this._onServerUpgrade);\n    }\n\n    delete this._server;\n  }\n\n  if (callback) callback(error);else if (error) throw error;\n};\n/**\n * Handle a HTTP Upgrade request.\n *\n * @api public\n */\n\n\nWebSocketServer.prototype.handleUpgrade = function (req, socket, upgradeHead, cb) {\n  // check for wrong path\n  if (this.options.path) {\n    var u = url.parse(req.url);\n    if (u && u.pathname !== this.options.path) return;\n  }\n\n  if (typeof req.headers.upgrade === 'undefined' || req.headers.upgrade.toLowerCase() !== 'websocket') {\n    abortConnection(socket, 400, 'Bad Request');\n    return;\n  }\n\n  if (req.headers['sec-websocket-key1']) handleHixieUpgrade.apply(this, arguments);else handleHybiUpgrade.apply(this, arguments);\n};\n\nmodule.exports = WebSocketServer;\n/**\n * Entirely private apis,\n * which may or may not be bound to a sepcific WebSocket instance.\n */\n\nfunction handleHybiUpgrade(req, socket, upgradeHead, cb) {\n  // handle premature socket errors\n  var errorHandler = function () {\n    try {\n      socket.destroy();\n    } catch (e) {}\n  };\n\n  socket.on('error', errorHandler); // verify key presence\n\n  if (!req.headers['sec-websocket-key']) {\n    abortConnection(socket, 400, 'Bad Request');\n    return;\n  } // verify version\n\n\n  var version = parseInt(req.headers['sec-websocket-version']);\n\n  if ([8, 13].indexOf(version) === -1) {\n    abortConnection(socket, 400, 'Bad Request');\n    return;\n  } // verify protocol\n\n\n  var protocols = req.headers['sec-websocket-protocol']; // verify client\n\n  var origin = version < 13 ? req.headers['sec-websocket-origin'] : req.headers['origin']; // handle extensions offer\n\n  var extensionsOffer = Extensions.parse(req.headers['sec-websocket-extensions']); // handler to call when the connection sequence completes\n\n  var self = this;\n\n  var completeHybiUpgrade2 = function (protocol) {\n    // calc key\n    var key = req.headers['sec-websocket-key'];\n    var shasum = crypto.createHash('sha1');\n    shasum.update(key + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\");\n    key = shasum.digest('base64');\n    var headers = ['HTTP/1.1 101 Switching Protocols', 'Upgrade: websocket', 'Connection: Upgrade', 'Sec-WebSocket-Accept: ' + key];\n\n    if (typeof protocol != 'undefined') {\n      headers.push('Sec-WebSocket-Protocol: ' + protocol);\n    }\n\n    var extensions = {};\n\n    try {\n      extensions = acceptExtensions.call(self, extensionsOffer);\n    } catch (err) {\n      abortConnection(socket, 400, 'Bad Request');\n      return;\n    }\n\n    if (Object.keys(extensions).length) {\n      var serverExtensions = {};\n      Object.keys(extensions).forEach(function (token) {\n        serverExtensions[token] = [extensions[token].params];\n      });\n      headers.push('Sec-WebSocket-Extensions: ' + Extensions.format(serverExtensions));\n    } // allows external modification/inspection of handshake headers\n\n\n    self.emit('headers', headers);\n    socket.setTimeout(0);\n    socket.setNoDelay(true);\n\n    try {\n      socket.write(headers.concat('', '').join('\\r\\n'));\n    } catch (e) {\n      // if the upgrade write fails, shut the connection down hard\n      try {\n        socket.destroy();\n      } catch (e) {}\n\n      return;\n    }\n\n    var client = new WebSocket([req, socket, upgradeHead], {\n      protocolVersion: version,\n      protocol: protocol,\n      extensions: extensions,\n      maxPayload: self.options.maxPayload\n    });\n\n    if (self.options.clientTracking) {\n      self.clients.push(client);\n      client.on('close', function () {\n        var index = self.clients.indexOf(client);\n\n        if (index != -1) {\n          self.clients.splice(index, 1);\n        }\n      });\n    } // signal upgrade complete\n\n\n    socket.removeListener('error', errorHandler);\n    cb(client);\n  }; // optionally call external protocol selection handler before\n  // calling completeHybiUpgrade2\n\n\n  var completeHybiUpgrade1 = function () {\n    // choose from the sub-protocols\n    if (typeof self.options.handleProtocols == 'function') {\n      var protList = (protocols || \"\").split(/, */);\n      var callbackCalled = false;\n      var res = self.options.handleProtocols(protList, function (result, protocol) {\n        callbackCalled = true;\n        if (!result) abortConnection(socket, 401, 'Unauthorized');else completeHybiUpgrade2(protocol);\n      });\n\n      if (!callbackCalled) {\n        // the handleProtocols handler never called our callback\n        abortConnection(socket, 501, 'Could not process protocols');\n      }\n\n      return;\n    } else {\n      if (typeof protocols !== 'undefined') {\n        completeHybiUpgrade2(protocols.split(/, */)[0]);\n      } else {\n        completeHybiUpgrade2();\n      }\n    }\n  }; // optionally call external client verification handler\n\n\n  if (typeof this.options.verifyClient == 'function') {\n    var info = {\n      origin: origin,\n      secure: typeof req.connection.authorized !== 'undefined' || typeof req.connection.encrypted !== 'undefined',\n      req: req\n    };\n\n    if (this.options.verifyClient.length == 2) {\n      this.options.verifyClient(info, function (result, code, name) {\n        if (typeof code === 'undefined') code = 401;\n        if (typeof name === 'undefined') name = http.STATUS_CODES[code];\n        if (!result) abortConnection(socket, code, name);else completeHybiUpgrade1();\n      });\n      return;\n    } else if (!this.options.verifyClient(info)) {\n      abortConnection(socket, 401, 'Unauthorized');\n      return;\n    }\n  }\n\n  completeHybiUpgrade1();\n}\n\nfunction handleHixieUpgrade(req, socket, upgradeHead, cb) {\n  // handle premature socket errors\n  var errorHandler = function () {\n    try {\n      socket.destroy();\n    } catch (e) {}\n  };\n\n  socket.on('error', errorHandler); // bail if options prevent hixie\n\n  if (this.options.disableHixie) {\n    abortConnection(socket, 401, 'Hixie support disabled');\n    return;\n  } // verify key presence\n\n\n  if (!req.headers['sec-websocket-key2']) {\n    abortConnection(socket, 400, 'Bad Request');\n    return;\n  }\n\n  var origin = req.headers['origin'],\n      self = this; // setup handshake completion to run after client has been verified\n\n  var onClientVerified = function () {\n    var wshost;\n    if (!req.headers['x-forwarded-host']) wshost = req.headers.host;else wshost = req.headers['x-forwarded-host'];\n    var location = (req.headers['x-forwarded-proto'] === 'https' || socket.encrypted ? 'wss' : 'ws') + '://' + wshost + req.url,\n        protocol = req.headers['sec-websocket-protocol']; // build the response header and return a Buffer\n\n    var buildResponseHeader = function () {\n      var headers = ['HTTP/1.1 101 Switching Protocols', 'Upgrade: WebSocket', 'Connection: Upgrade', 'Sec-WebSocket-Location: ' + location];\n      if (typeof protocol != 'undefined') headers.push('Sec-WebSocket-Protocol: ' + protocol);\n      if (typeof origin != 'undefined') headers.push('Sec-WebSocket-Origin: ' + origin);\n      return new Buffer(headers.concat('', '').join('\\r\\n'));\n    }; // send handshake response before receiving the nonce\n\n\n    var handshakeResponse = function () {\n      socket.setTimeout(0);\n      socket.setNoDelay(true);\n      var headerBuffer = buildResponseHeader();\n\n      try {\n        socket.write(headerBuffer, 'binary', function (err) {\n          // remove listener if there was an error\n          if (err) socket.removeListener('data', handler);\n          return;\n        });\n      } catch (e) {\n        try {\n          socket.destroy();\n        } catch (e) {}\n\n        return;\n      }\n\n      ;\n    }; // handshake completion code to run once nonce has been successfully retrieved\n\n\n    var completeHandshake = function (nonce, rest, headerBuffer) {\n      // calculate key\n      var k1 = req.headers['sec-websocket-key1'],\n          k2 = req.headers['sec-websocket-key2'],\n          md5 = crypto.createHash('md5');\n      [k1, k2].forEach(function (k) {\n        var n = parseInt(k.replace(/[^\\d]/g, '')),\n            spaces = k.replace(/[^ ]/g, '').length;\n\n        if (spaces === 0 || n % spaces !== 0) {\n          abortConnection(socket, 400, 'Bad Request');\n          return;\n        }\n\n        n /= spaces;\n        md5.update(String.fromCharCode(n >> 24 & 0xFF, n >> 16 & 0xFF, n >> 8 & 0xFF, n & 0xFF));\n      });\n      md5.update(nonce.toString('binary'));\n      socket.setTimeout(0);\n      socket.setNoDelay(true);\n\n      try {\n        var hashBuffer = new Buffer(md5.digest('binary'), 'binary');\n        var handshakeBuffer = new Buffer(headerBuffer.length + hashBuffer.length);\n        headerBuffer.copy(handshakeBuffer, 0);\n        hashBuffer.copy(handshakeBuffer, headerBuffer.length); // do a single write, which - upon success - causes a new client websocket to be setup\n\n        socket.write(handshakeBuffer, 'binary', function (err) {\n          if (err) return; // do not create client if an error happens\n\n          var client = new WebSocket([req, socket, rest], {\n            protocolVersion: 'hixie-76',\n            protocol: protocol\n          });\n\n          if (self.options.clientTracking) {\n            self.clients.push(client);\n            client.on('close', function () {\n              var index = self.clients.indexOf(client);\n\n              if (index != -1) {\n                self.clients.splice(index, 1);\n              }\n            });\n          } // signal upgrade complete\n\n\n          socket.removeListener('error', errorHandler);\n          cb(client);\n        });\n      } catch (e) {\n        try {\n          socket.destroy();\n        } catch (e) {}\n\n        return;\n      }\n    }; // retrieve nonce\n\n\n    var nonceLength = 8;\n\n    if (upgradeHead && upgradeHead.length >= nonceLength) {\n      var nonce = upgradeHead.slice(0, nonceLength);\n      var rest = upgradeHead.length > nonceLength ? upgradeHead.slice(nonceLength) : null;\n      completeHandshake.call(self, nonce, rest, buildResponseHeader());\n    } else {\n      // nonce not present in upgradeHead\n      var nonce = new Buffer(nonceLength);\n      upgradeHead.copy(nonce, 0);\n      var received = upgradeHead.length;\n      var rest = null;\n\n      var handler = function (data) {\n        var toRead = Math.min(data.length, nonceLength - received);\n        if (toRead === 0) return;\n        data.copy(nonce, received, 0, toRead);\n        received += toRead;\n\n        if (received == nonceLength) {\n          socket.removeListener('data', handler);\n          if (toRead < data.length) rest = data.slice(toRead); // complete the handshake but send empty buffer for headers since they have already been sent\n\n          completeHandshake.call(self, nonce, rest, new Buffer(0));\n        }\n      }; // handle additional data as we receive it\n\n\n      socket.on('data', handler); // send header response before we have the nonce to fix haproxy buffering\n\n      handshakeResponse();\n    }\n  }; // verify client\n\n\n  if (typeof this.options.verifyClient == 'function') {\n    var info = {\n      origin: origin,\n      secure: typeof req.connection.authorized !== 'undefined' || typeof req.connection.encrypted !== 'undefined',\n      req: req\n    };\n\n    if (this.options.verifyClient.length == 2) {\n      var self = this;\n      this.options.verifyClient(info, function (result, code, name) {\n        if (typeof code === 'undefined') code = 401;\n        if (typeof name === 'undefined') name = http.STATUS_CODES[code];\n        if (!result) abortConnection(socket, code, name);else onClientVerified.apply(self);\n      });\n      return;\n    } else if (!this.options.verifyClient(info)) {\n      abortConnection(socket, 401, 'Unauthorized');\n      return;\n    }\n  } // no client verification required\n\n\n  onClientVerified();\n}\n\nfunction acceptExtensions(offer) {\n  var extensions = {};\n  var options = this.options.perMessageDeflate;\n  var maxPayload = this.options.maxPayload;\n\n  if (options && offer[PerMessageDeflate.extensionName]) {\n    var perMessageDeflate = new PerMessageDeflate(options !== true ? options : {}, true, maxPayload);\n    perMessageDeflate.accept(offer[PerMessageDeflate.extensionName]);\n    extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n  }\n\n  return extensions;\n}\n\nfunction abortConnection(socket, code, name) {\n  try {\n    var response = ['HTTP/1.1 ' + code + ' ' + name, 'Content-type: text/html'];\n    socket.write(response.concat('', '').join('\\r\\n'));\n  } catch (e) {\n    /* ignore errors - we've aborted this connection */\n  } finally {\n    // ensure that an early aborted connection is shut down completely\n    try {\n      socket.destroy();\n    } catch (e) {}\n  }\n}","map":{"version":3,"sources":["/home/subho/Programming/Internet-Technology/Athena/node_modules/ws/lib/WebSocketServer.js"],"names":["util","require","events","http","crypto","Options","WebSocket","Extensions","PerMessageDeflate","tls","url","WebSocketServer","options","callback","EventEmitter","call","host","port","server","verifyClient","handleProtocols","path","noServer","disableHixie","clientTracking","perMessageDeflate","maxPayload","merge","isDefinedAndNonNull","value","TypeError","self","_server","createServer","req","res","body","STATUS_CODES","writeHead","length","end","allowHalfOpen","listen","_closeServer","close","_webSocketPaths","Error","_onceServerListening","emit","once","_onServerError","error","on","_onServerUpgrade","socket","upgradeHead","head","Buffer","copy","handleUpgrade","client","clients","inherits","prototype","i","l","terminate","e","Object","keys","removeListener","cb","u","parse","pathname","headers","upgrade","toLowerCase","abortConnection","handleHixieUpgrade","apply","arguments","handleHybiUpgrade","module","exports","errorHandler","destroy","version","parseInt","indexOf","protocols","origin","extensionsOffer","completeHybiUpgrade2","protocol","key","shasum","createHash","update","digest","push","extensions","acceptExtensions","err","serverExtensions","forEach","token","params","format","setTimeout","setNoDelay","write","concat","join","protocolVersion","index","splice","completeHybiUpgrade1","protList","split","callbackCalled","result","info","secure","connection","authorized","encrypted","code","name","onClientVerified","wshost","location","buildResponseHeader","handshakeResponse","headerBuffer","handler","completeHandshake","nonce","rest","k1","k2","md5","k","n","replace","spaces","String","fromCharCode","toString","hashBuffer","handshakeBuffer","nonceLength","slice","received","data","toRead","Math","min","offer","extensionName","accept","response"],"mappings":"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","sourcesContent":["/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nvar util = require('util')\n  , events = require('events')\n  , http = require('http')\n  , crypto = require('crypto')\n  , Options = require('options')\n  , WebSocket = require('./WebSocket')\n  , Extensions = require('./Extensions')\n  , PerMessageDeflate = require('./PerMessageDeflate')\n  , tls = require('tls')\n  , url = require('url');\n\n/**\n * WebSocket Server implementation\n */\n\nfunction WebSocketServer(options, callback) {\n  if (this instanceof WebSocketServer === false) {\n    return new WebSocketServer(options, callback);\n  }\n\n  events.EventEmitter.call(this);\n\n  options = new Options({\n    host: '0.0.0.0',\n    port: null,\n    server: null,\n    verifyClient: null,\n    handleProtocols: null,\n    path: null,\n    noServer: false,\n    disableHixie: false,\n    clientTracking: true,\n    perMessageDeflate: true,\n    maxPayload: 100 * 1024 * 1024\n  }).merge(options);\n\n  if (!options.isDefinedAndNonNull('port') && !options.isDefinedAndNonNull('server') && !options.value.noServer) {\n    throw new TypeError('`port` or a `server` must be provided');\n  }\n\n  var self = this;\n\n  if (options.isDefinedAndNonNull('port')) {\n    this._server = http.createServer(function (req, res) {\n      var body = http.STATUS_CODES[426];\n      res.writeHead(426, {\n        'Content-Length': body.length,\n        'Content-Type': 'text/plain'\n      });\n      res.end(body);\n    });\n    this._server.allowHalfOpen = false;\n    this._server.listen(options.value.port, options.value.host, callback);\n    this._closeServer = function() { if (self._server) self._server.close(); };\n  }\n  else if (options.value.server) {\n    this._server = options.value.server;\n    if (options.value.path) {\n      // take note of the path, to avoid collisions when multiple websocket servers are\n      // listening on the same http server\n      if (this._server._webSocketPaths && options.value.server._webSocketPaths[options.value.path]) {\n        throw new Error('two instances of WebSocketServer cannot listen on the same http server path');\n      }\n      if (typeof this._server._webSocketPaths !== 'object') {\n        this._server._webSocketPaths = {};\n      }\n      this._server._webSocketPaths[options.value.path] = 1;\n    }\n  }\n  if (this._server) {\n    this._onceServerListening = function() { self.emit('listening'); };\n    this._server.once('listening', this._onceServerListening);\n  }\n\n  if (typeof this._server != 'undefined') {\n    this._onServerError = function(error) { self.emit('error', error) };\n    this._server.on('error', this._onServerError);\n    this._onServerUpgrade = function(req, socket, upgradeHead) {\n      //copy upgradeHead to avoid retention of large slab buffers used in node core\n      var head = new Buffer(upgradeHead.length);\n      upgradeHead.copy(head);\n\n      self.handleUpgrade(req, socket, head, function(client) {\n        self.emit('connection'+req.url, client);\n        self.emit('connection', client);\n      });\n    };\n    this._server.on('upgrade', this._onServerUpgrade);\n  }\n\n  this.options = options.value;\n  this.path = options.value.path;\n  this.clients = [];\n}\n\n/**\n * Inherits from EventEmitter.\n */\n\nutil.inherits(WebSocketServer, events.EventEmitter);\n\n/**\n * Immediately shuts down the connection.\n *\n * @api public\n */\n\nWebSocketServer.prototype.close = function(callback) {\n  // terminate all associated clients\n  var error = null;\n  try {\n    for (var i = 0, l = this.clients.length; i < l; ++i) {\n      this.clients[i].terminate();\n    }\n  }\n  catch (e) {\n    error = e;\n  }\n\n  // remove path descriptor, if any\n  if (this.path && this._server._webSocketPaths) {\n    delete this._server._webSocketPaths[this.path];\n    if (Object.keys(this._server._webSocketPaths).length == 0) {\n      delete this._server._webSocketPaths;\n    }\n  }\n\n  // close the http server if it was internally created\n  try {\n    if (typeof this._closeServer !== 'undefined') {\n      this._closeServer();\n    }\n  }\n  finally {\n    if (this._server) {\n      this._server.removeListener('listening', this._onceServerListening);\n      this._server.removeListener('error', this._onServerError);\n      this._server.removeListener('upgrade', this._onServerUpgrade);\n    }\n    delete this._server;\n  }\n  if(callback)\n    callback(error);\n  else if(error)\n    throw error;\n}\n\n/**\n * Handle a HTTP Upgrade request.\n *\n * @api public\n */\n\nWebSocketServer.prototype.handleUpgrade = function(req, socket, upgradeHead, cb) {\n  // check for wrong path\n  if (this.options.path) {\n    var u = url.parse(req.url);\n    if (u && u.pathname !== this.options.path) return;\n  }\n\n  if (typeof req.headers.upgrade === 'undefined' || req.headers.upgrade.toLowerCase() !== 'websocket') {\n    abortConnection(socket, 400, 'Bad Request');\n    return;\n  }\n\n  if (req.headers['sec-websocket-key1']) handleHixieUpgrade.apply(this, arguments);\n  else handleHybiUpgrade.apply(this, arguments);\n}\n\nmodule.exports = WebSocketServer;\n\n/**\n * Entirely private apis,\n * which may or may not be bound to a sepcific WebSocket instance.\n */\n\nfunction handleHybiUpgrade(req, socket, upgradeHead, cb) {\n  // handle premature socket errors\n  var errorHandler = function() {\n    try { socket.destroy(); } catch (e) {}\n  }\n  socket.on('error', errorHandler);\n\n  // verify key presence\n  if (!req.headers['sec-websocket-key']) {\n    abortConnection(socket, 400, 'Bad Request');\n    return;\n  }\n\n  // verify version\n  var version = parseInt(req.headers['sec-websocket-version']);\n  if ([8, 13].indexOf(version) === -1) {\n    abortConnection(socket, 400, 'Bad Request');\n    return;\n  }\n\n  // verify protocol\n  var protocols = req.headers['sec-websocket-protocol'];\n\n  // verify client\n  var origin = version < 13 ?\n    req.headers['sec-websocket-origin'] :\n    req.headers['origin'];\n\n  // handle extensions offer\n  var extensionsOffer = Extensions.parse(req.headers['sec-websocket-extensions']);\n\n  // handler to call when the connection sequence completes\n  var self = this;\n  var completeHybiUpgrade2 = function(protocol) {\n\n    // calc key\n    var key = req.headers['sec-websocket-key'];\n    var shasum = crypto.createHash('sha1');\n    shasum.update(key + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\");\n    key = shasum.digest('base64');\n\n    var headers = [\n        'HTTP/1.1 101 Switching Protocols'\n      , 'Upgrade: websocket'\n      , 'Connection: Upgrade'\n      , 'Sec-WebSocket-Accept: ' + key\n    ];\n\n    if (typeof protocol != 'undefined') {\n      headers.push('Sec-WebSocket-Protocol: ' + protocol);\n    }\n\n    var extensions = {};\n    try {\n      extensions = acceptExtensions.call(self, extensionsOffer);\n    } catch (err) {\n      abortConnection(socket, 400, 'Bad Request');\n      return;\n    }\n\n    if (Object.keys(extensions).length) {\n      var serverExtensions = {};\n      Object.keys(extensions).forEach(function(token) {\n        serverExtensions[token] = [extensions[token].params]\n      });\n      headers.push('Sec-WebSocket-Extensions: ' + Extensions.format(serverExtensions));\n    }\n\n    // allows external modification/inspection of handshake headers\n    self.emit('headers', headers);\n\n    socket.setTimeout(0);\n    socket.setNoDelay(true);\n    try {\n      socket.write(headers.concat('', '').join('\\r\\n'));\n    }\n    catch (e) {\n      // if the upgrade write fails, shut the connection down hard\n      try { socket.destroy(); } catch (e) {}\n      return;\n    }\n\n    var client = new WebSocket([req, socket, upgradeHead], {\n      protocolVersion: version,\n      protocol: protocol,\n      extensions: extensions,\n      maxPayload: self.options.maxPayload\n    });\n\n    if (self.options.clientTracking) {\n      self.clients.push(client);\n      client.on('close', function() {\n        var index = self.clients.indexOf(client);\n        if (index != -1) {\n          self.clients.splice(index, 1);\n        }\n      });\n    }\n\n    // signal upgrade complete\n    socket.removeListener('error', errorHandler);\n    cb(client);\n  }\n\n  // optionally call external protocol selection handler before\n  // calling completeHybiUpgrade2\n  var completeHybiUpgrade1 = function() {\n    // choose from the sub-protocols\n    if (typeof self.options.handleProtocols == 'function') {\n        var protList = (protocols || \"\").split(/, */);\n        var callbackCalled = false;\n        var res = self.options.handleProtocols(protList, function(result, protocol) {\n          callbackCalled = true;\n          if (!result) abortConnection(socket, 401, 'Unauthorized');\n          else completeHybiUpgrade2(protocol);\n        });\n        if (!callbackCalled) {\n            // the handleProtocols handler never called our callback\n            abortConnection(socket, 501, 'Could not process protocols');\n        }\n        return;\n    } else {\n        if (typeof protocols !== 'undefined') {\n            completeHybiUpgrade2(protocols.split(/, */)[0]);\n        }\n        else {\n            completeHybiUpgrade2();\n        }\n    }\n  }\n\n  // optionally call external client verification handler\n  if (typeof this.options.verifyClient == 'function') {\n    var info = {\n      origin: origin,\n      secure: typeof req.connection.authorized !== 'undefined' || typeof req.connection.encrypted !== 'undefined',\n      req: req\n    };\n    if (this.options.verifyClient.length == 2) {\n      this.options.verifyClient(info, function(result, code, name) {\n        if (typeof code === 'undefined') code = 401;\n        if (typeof name === 'undefined') name = http.STATUS_CODES[code];\n\n        if (!result) abortConnection(socket, code, name);\n        else completeHybiUpgrade1();\n      });\n      return;\n    }\n    else if (!this.options.verifyClient(info)) {\n      abortConnection(socket, 401, 'Unauthorized');\n      return;\n    }\n  }\n\n  completeHybiUpgrade1();\n}\n\nfunction handleHixieUpgrade(req, socket, upgradeHead, cb) {\n  // handle premature socket errors\n  var errorHandler = function() {\n    try { socket.destroy(); } catch (e) {}\n  }\n  socket.on('error', errorHandler);\n\n  // bail if options prevent hixie\n  if (this.options.disableHixie) {\n    abortConnection(socket, 401, 'Hixie support disabled');\n    return;\n  }\n\n  // verify key presence\n  if (!req.headers['sec-websocket-key2']) {\n    abortConnection(socket, 400, 'Bad Request');\n    return;\n  }\n\n  var origin = req.headers['origin']\n    , self = this;\n\n  // setup handshake completion to run after client has been verified\n  var onClientVerified = function() {\n    var wshost;\n    if (!req.headers['x-forwarded-host'])\n        wshost = req.headers.host;\n    else\n        wshost = req.headers['x-forwarded-host'];\n    var location = ((req.headers['x-forwarded-proto'] === 'https' || socket.encrypted) ? 'wss' : 'ws') + '://' + wshost + req.url\n      , protocol = req.headers['sec-websocket-protocol'];\n\n    // build the response header and return a Buffer\n    var buildResponseHeader = function() {\n      var headers = [\n          'HTTP/1.1 101 Switching Protocols'\n        , 'Upgrade: WebSocket'\n        , 'Connection: Upgrade'\n        , 'Sec-WebSocket-Location: ' + location\n      ];\n      if (typeof protocol != 'undefined') headers.push('Sec-WebSocket-Protocol: ' + protocol);\n      if (typeof origin != 'undefined') headers.push('Sec-WebSocket-Origin: ' + origin);\n\n      return new Buffer(headers.concat('', '').join('\\r\\n'));\n    };\n\n    // send handshake response before receiving the nonce\n    var handshakeResponse = function() {\n\n      socket.setTimeout(0);\n      socket.setNoDelay(true);\n\n      var headerBuffer = buildResponseHeader();\n\n      try {\n        socket.write(headerBuffer, 'binary', function(err) {\n          // remove listener if there was an error\n          if (err) socket.removeListener('data', handler);\n          return;\n        });\n      } catch (e) {\n        try { socket.destroy(); } catch (e) {}\n        return;\n      };\n    };\n\n    // handshake completion code to run once nonce has been successfully retrieved\n    var completeHandshake = function(nonce, rest, headerBuffer) {\n      // calculate key\n      var k1 = req.headers['sec-websocket-key1']\n        , k2 = req.headers['sec-websocket-key2']\n        , md5 = crypto.createHash('md5');\n\n      [k1, k2].forEach(function (k) {\n        var n = parseInt(k.replace(/[^\\d]/g, ''))\n          , spaces = k.replace(/[^ ]/g, '').length;\n        if (spaces === 0 || n % spaces !== 0){\n          abortConnection(socket, 400, 'Bad Request');\n          return;\n        }\n        n /= spaces;\n        md5.update(String.fromCharCode(\n          n >> 24 & 0xFF,\n          n >> 16 & 0xFF,\n          n >> 8  & 0xFF,\n          n       & 0xFF));\n      });\n      md5.update(nonce.toString('binary'));\n\n      socket.setTimeout(0);\n      socket.setNoDelay(true);\n\n      try {\n        var hashBuffer = new Buffer(md5.digest('binary'), 'binary');\n        var handshakeBuffer = new Buffer(headerBuffer.length + hashBuffer.length);\n        headerBuffer.copy(handshakeBuffer, 0);\n        hashBuffer.copy(handshakeBuffer, headerBuffer.length);\n\n        // do a single write, which - upon success - causes a new client websocket to be setup\n        socket.write(handshakeBuffer, 'binary', function(err) {\n          if (err) return; // do not create client if an error happens\n          var client = new WebSocket([req, socket, rest], {\n            protocolVersion: 'hixie-76',\n            protocol: protocol\n          });\n          if (self.options.clientTracking) {\n            self.clients.push(client);\n            client.on('close', function() {\n              var index = self.clients.indexOf(client);\n              if (index != -1) {\n                self.clients.splice(index, 1);\n              }\n            });\n          }\n\n          // signal upgrade complete\n          socket.removeListener('error', errorHandler);\n          cb(client);\n        });\n      }\n      catch (e) {\n        try { socket.destroy(); } catch (e) {}\n        return;\n      }\n    }\n\n    // retrieve nonce\n    var nonceLength = 8;\n    if (upgradeHead && upgradeHead.length >= nonceLength) {\n      var nonce = upgradeHead.slice(0, nonceLength);\n      var rest = upgradeHead.length > nonceLength ? upgradeHead.slice(nonceLength) : null;\n      completeHandshake.call(self, nonce, rest, buildResponseHeader());\n    }\n    else {\n      // nonce not present in upgradeHead\n      var nonce = new Buffer(nonceLength);\n      upgradeHead.copy(nonce, 0);\n      var received = upgradeHead.length;\n      var rest = null;\n      var handler = function (data) {\n        var toRead = Math.min(data.length, nonceLength - received);\n        if (toRead === 0) return;\n        data.copy(nonce, received, 0, toRead);\n        received += toRead;\n        if (received == nonceLength) {\n          socket.removeListener('data', handler);\n          if (toRead < data.length) rest = data.slice(toRead);\n\n          // complete the handshake but send empty buffer for headers since they have already been sent\n          completeHandshake.call(self, nonce, rest, new Buffer(0));\n        }\n      }\n\n      // handle additional data as we receive it\n      socket.on('data', handler);\n\n      // send header response before we have the nonce to fix haproxy buffering\n      handshakeResponse();\n    }\n  }\n\n  // verify client\n  if (typeof this.options.verifyClient == 'function') {\n    var info = {\n      origin: origin,\n      secure: typeof req.connection.authorized !== 'undefined' || typeof req.connection.encrypted !== 'undefined',\n      req: req\n    };\n    if (this.options.verifyClient.length == 2) {\n      var self = this;\n      this.options.verifyClient(info, function(result, code, name) {\n        if (typeof code === 'undefined') code = 401;\n        if (typeof name === 'undefined') name = http.STATUS_CODES[code];\n\n        if (!result) abortConnection(socket, code, name);\n        else onClientVerified.apply(self);\n      });\n      return;\n    }\n    else if (!this.options.verifyClient(info)) {\n      abortConnection(socket, 401, 'Unauthorized');\n      return;\n    }\n  }\n\n  // no client verification required\n  onClientVerified();\n}\n\nfunction acceptExtensions(offer) {\n  var extensions = {};\n  var options = this.options.perMessageDeflate;\n  var maxPayload = this.options.maxPayload;\n  if (options && offer[PerMessageDeflate.extensionName]) {\n    var perMessageDeflate = new PerMessageDeflate(options !== true ? options : {}, true, maxPayload);\n    perMessageDeflate.accept(offer[PerMessageDeflate.extensionName]);\n    extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n  }\n  return extensions;\n}\n\nfunction abortConnection(socket, code, name) {\n  try {\n    var response = [\n      'HTTP/1.1 ' + code + ' ' + name,\n      'Content-type: text/html'\n    ];\n    socket.write(response.concat('', '').join('\\r\\n'));\n  }\n  catch (e) { /* ignore errors - we've aborted this connection */ }\n  finally {\n    // ensure that an early aborted connection is shut down completely\n    try { socket.destroy(); } catch (e) {}\n  }\n}\n"]},"metadata":{},"sourceType":"script"}