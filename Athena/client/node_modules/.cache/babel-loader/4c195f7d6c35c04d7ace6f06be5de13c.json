{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar Socket = require('./socket');\n\nvar Emitter = require('events').EventEmitter;\n\nvar parser = require('socket.io-parser');\n\nvar debug = require('debug')('socket.io:namespace');\n\nvar hasBin = require('has-binary');\n/**\n * Module exports.\n */\n\n\nmodule.exports = exports = Namespace;\n/**\n * Blacklisted events.\n */\n\nexports.events = ['connect', // for symmetry with client\n'connection', 'newListener'];\n/**\n * Flags.\n */\n\nexports.flags = ['json', 'volatile', 'local'];\n/**\n * `EventEmitter#emit` reference.\n */\n\nvar emit = Emitter.prototype.emit;\n/**\n * Namespace constructor.\n *\n * @param {Server} server instance\n * @param {Socket} name\n * @api private\n */\n\nfunction Namespace(server, name) {\n  this.name = name;\n  this.server = server;\n  this.sockets = {};\n  this.connected = {};\n  this.fns = [];\n  this.ids = 0;\n  this.initAdapter();\n}\n/**\n * Inherits from `EventEmitter`.\n */\n\n\nNamespace.prototype.__proto__ = Emitter.prototype;\n/**\n * Apply flags from `Socket`.\n */\n\nexports.flags.forEach(function (flag) {\n  Object.defineProperty(Namespace.prototype, flag, {\n    get: function () {\n      this.flags = this.flags || {};\n      this.flags[flag] = true;\n      return this;\n    }\n  });\n});\n/**\n * Initializes the `Adapter` for this nsp.\n * Run upon changing adapter by `Server#adapter`\n * in addition to the constructor.\n *\n * @api private\n */\n\nNamespace.prototype.initAdapter = function () {\n  this.adapter = new (this.server.adapter())(this);\n};\n/**\n * Sets up namespace middleware.\n *\n * @return {Namespace} self\n * @api public\n */\n\n\nNamespace.prototype.use = function (fn) {\n  this.fns.push(fn);\n  return this;\n};\n/**\n * Executes the middleware for an incoming client.\n *\n * @param {Socket} socket that will get added\n * @param {Function} fn last fn call in the middleware\n * @api private\n */\n\n\nNamespace.prototype.run = function (socket, fn) {\n  var fns = this.fns.slice(0);\n  if (!fns.length) return fn(null);\n\n  function run(i) {\n    fns[i](socket, function (err) {\n      // upon error, short-circuit\n      if (err) return fn(err); // if no middleware left, summon callback\n\n      if (!fns[i + 1]) return fn(null); // go on to next\n\n      run(i + 1);\n    });\n  }\n\n  run(0);\n};\n/**\n * Targets a room when emitting.\n *\n * @param {String} name\n * @return {Namespace} self\n * @api public\n */\n\n\nNamespace.prototype.to = Namespace.prototype.in = function (name) {\n  this.rooms = this.rooms || [];\n  if (!~this.rooms.indexOf(name)) this.rooms.push(name);\n  return this;\n};\n/**\n * Adds a new client.\n *\n * @return {Socket}\n * @api private\n */\n\n\nNamespace.prototype.add = function (client, query, fn) {\n  debug('adding socket to nsp %s', this.name);\n  var socket = new Socket(this, client, query);\n  var self = this;\n  this.run(socket, function (err) {\n    process.nextTick(function () {\n      if ('open' == client.conn.readyState) {\n        if (err) return socket.error(err.data || err.message); // track socket\n\n        self.sockets[socket.id] = socket; // it's paramount that the internal `onconnect` logic\n        // fires before user-set events to prevent state order\n        // violations (such as a disconnection before the connection\n        // logic is complete)\n\n        socket.onconnect();\n        if (fn) fn(); // fire user-set events\n\n        self.emit('connect', socket);\n        self.emit('connection', socket);\n      } else {\n        debug('next called after client was closed - ignoring socket');\n      }\n    });\n  });\n  return socket;\n};\n/**\n * Removes a client. Called by each `Socket`.\n *\n * @api private\n */\n\n\nNamespace.prototype.remove = function (socket) {\n  if (this.sockets.hasOwnProperty(socket.id)) {\n    delete this.sockets[socket.id];\n  } else {\n    debug('ignoring remove for %s', socket.id);\n  }\n};\n/**\n * Emits to all clients.\n *\n * @return {Namespace} self\n * @api public\n */\n\n\nNamespace.prototype.emit = function (ev) {\n  if (~exports.events.indexOf(ev)) {\n    emit.apply(this, arguments);\n  } else {\n    // set up packet object\n    var args = Array.prototype.slice.call(arguments);\n    var parserType = parser.EVENT; // default\n\n    if (hasBin(args)) {\n      parserType = parser.BINARY_EVENT;\n    } // binary\n\n\n    var packet = {\n      type: parserType,\n      data: args\n    };\n\n    if ('function' == typeof args[args.length - 1]) {\n      throw new Error('Callbacks are not supported when broadcasting');\n    }\n\n    this.adapter.broadcast(packet, {\n      rooms: this.rooms,\n      flags: this.flags\n    });\n    delete this.rooms;\n    delete this.flags;\n  }\n\n  return this;\n};\n/**\n * Sends a `message` event to all clients.\n *\n * @return {Namespace} self\n * @api public\n */\n\n\nNamespace.prototype.send = Namespace.prototype.write = function () {\n  var args = Array.prototype.slice.call(arguments);\n  args.unshift('message');\n  this.emit.apply(this, args);\n  return this;\n};\n/**\n * Gets a list of clients.\n *\n * @return {Namespace} self\n * @api public\n */\n\n\nNamespace.prototype.clients = function (fn) {\n  this.adapter.clients(this.rooms, fn); // delete rooms flag for scenario:\n  // .in('room').clients() (GH-1978)\n\n  delete this.rooms;\n  return this;\n};\n/**\n * Sets the compress flag.\n *\n * @param {Boolean} compress if `true`, compresses the sending data\n * @return {Socket} self\n * @api public\n */\n\n\nNamespace.prototype.compress = function (compress) {\n  this.flags = this.flags || {};\n  this.flags.compress = compress;\n  return this;\n};","map":{"version":3,"sources":["/home/subho/Programming/Internet-Technology/Athena/node_modules/socket.io/lib/namespace.js"],"names":["Socket","require","Emitter","EventEmitter","parser","debug","hasBin","module","exports","Namespace","events","flags","emit","prototype","server","name","sockets","connected","fns","ids","initAdapter","__proto__","forEach","flag","Object","defineProperty","get","adapter","use","fn","push","run","socket","slice","length","i","err","to","in","rooms","indexOf","add","client","query","self","process","nextTick","conn","readyState","error","data","message","id","onconnect","remove","hasOwnProperty","ev","apply","arguments","args","Array","call","parserType","EVENT","BINARY_EVENT","packet","type","Error","broadcast","send","write","unshift","clients","compress"],"mappings":"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","sourcesContent":["\n/**\n * Module dependencies.\n */\n\nvar Socket = require('./socket');\nvar Emitter = require('events').EventEmitter;\nvar parser = require('socket.io-parser');\nvar debug = require('debug')('socket.io:namespace');\nvar hasBin = require('has-binary');\n\n/**\n * Module exports.\n */\n\nmodule.exports = exports = Namespace;\n\n/**\n * Blacklisted events.\n */\n\nexports.events = [\n  'connect',    // for symmetry with client\n  'connection',\n  'newListener'\n];\n\n/**\n * Flags.\n */\n\nexports.flags = [\n  'json',\n  'volatile',\n  'local'\n];\n\n/**\n * `EventEmitter#emit` reference.\n */\n\nvar emit = Emitter.prototype.emit;\n\n/**\n * Namespace constructor.\n *\n * @param {Server} server instance\n * @param {Socket} name\n * @api private\n */\n\nfunction Namespace(server, name){\n  this.name = name;\n  this.server = server;\n  this.sockets = {};\n  this.connected = {};\n  this.fns = [];\n  this.ids = 0;\n  this.initAdapter();\n}\n\n/**\n * Inherits from `EventEmitter`.\n */\n\nNamespace.prototype.__proto__ = Emitter.prototype;\n\n/**\n * Apply flags from `Socket`.\n */\n\nexports.flags.forEach(function(flag){\n  Object.defineProperty(Namespace.prototype, flag, {\n    get: function() {\n      this.flags = this.flags || {};\n      this.flags[flag] = true;\n      return this;\n    }\n  });\n});\n\n/**\n * Initializes the `Adapter` for this nsp.\n * Run upon changing adapter by `Server#adapter`\n * in addition to the constructor.\n *\n * @api private\n */\n\nNamespace.prototype.initAdapter = function(){\n  this.adapter = new (this.server.adapter())(this);\n};\n\n/**\n * Sets up namespace middleware.\n *\n * @return {Namespace} self\n * @api public\n */\n\nNamespace.prototype.use = function(fn){\n  this.fns.push(fn);\n  return this;\n};\n\n/**\n * Executes the middleware for an incoming client.\n *\n * @param {Socket} socket that will get added\n * @param {Function} fn last fn call in the middleware\n * @api private\n */\n\nNamespace.prototype.run = function(socket, fn){\n  var fns = this.fns.slice(0);\n  if (!fns.length) return fn(null);\n\n  function run(i){\n    fns[i](socket, function(err){\n      // upon error, short-circuit\n      if (err) return fn(err);\n\n      // if no middleware left, summon callback\n      if (!fns[i + 1]) return fn(null);\n\n      // go on to next\n      run(i + 1);\n    });\n  }\n\n  run(0);\n};\n\n/**\n * Targets a room when emitting.\n *\n * @param {String} name\n * @return {Namespace} self\n * @api public\n */\n\nNamespace.prototype.to =\nNamespace.prototype.in = function(name){\n  this.rooms = this.rooms || [];\n  if (!~this.rooms.indexOf(name)) this.rooms.push(name);\n  return this;\n};\n\n/**\n * Adds a new client.\n *\n * @return {Socket}\n * @api private\n */\n\nNamespace.prototype.add = function(client, query, fn){\n  debug('adding socket to nsp %s', this.name);\n  var socket = new Socket(this, client, query);\n  var self = this;\n  this.run(socket, function(err){\n    process.nextTick(function(){\n      if ('open' == client.conn.readyState) {\n        if (err) return socket.error(err.data || err.message);\n\n        // track socket\n        self.sockets[socket.id] = socket;\n\n        // it's paramount that the internal `onconnect` logic\n        // fires before user-set events to prevent state order\n        // violations (such as a disconnection before the connection\n        // logic is complete)\n        socket.onconnect();\n        if (fn) fn();\n\n        // fire user-set events\n        self.emit('connect', socket);\n        self.emit('connection', socket);\n      } else {\n        debug('next called after client was closed - ignoring socket');\n      }\n    });\n  });\n  return socket;\n};\n\n/**\n * Removes a client. Called by each `Socket`.\n *\n * @api private\n */\n\nNamespace.prototype.remove = function(socket){\n  if (this.sockets.hasOwnProperty(socket.id)) {\n    delete this.sockets[socket.id];\n  } else {\n    debug('ignoring remove for %s', socket.id);\n  }\n};\n\n/**\n * Emits to all clients.\n *\n * @return {Namespace} self\n * @api public\n */\n\nNamespace.prototype.emit = function(ev){\n  if (~exports.events.indexOf(ev)) {\n    emit.apply(this, arguments);\n  } else {\n    // set up packet object\n    var args = Array.prototype.slice.call(arguments);\n    var parserType = parser.EVENT; // default\n    if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary\n\n    var packet = { type: parserType, data: args };\n\n    if ('function' == typeof args[args.length - 1]) {\n      throw new Error('Callbacks are not supported when broadcasting');\n    }\n\n    this.adapter.broadcast(packet, {\n      rooms: this.rooms,\n      flags: this.flags\n    });\n\n    delete this.rooms;\n    delete this.flags;\n  }\n  return this;\n};\n\n/**\n * Sends a `message` event to all clients.\n *\n * @return {Namespace} self\n * @api public\n */\n\nNamespace.prototype.send =\nNamespace.prototype.write = function(){\n  var args = Array.prototype.slice.call(arguments);\n  args.unshift('message');\n  this.emit.apply(this, args);\n  return this;\n};\n\n/**\n * Gets a list of clients.\n *\n * @return {Namespace} self\n * @api public\n */\n\nNamespace.prototype.clients = function(fn){\n  this.adapter.clients(this.rooms, fn);\n  // delete rooms flag for scenario:\n  // .in('room').clients() (GH-1978)\n  delete this.rooms;\n  return this;\n};\n\n/**\n * Sets the compress flag.\n *\n * @param {Boolean} compress if `true`, compresses the sending data\n * @return {Socket} self\n * @api public\n */\n\nNamespace.prototype.compress = function(compress){\n  this.flags = this.flags || {};\n  this.flags.compress = compress;\n  return this;\n};\n"]},"metadata":{},"sourceType":"script"}