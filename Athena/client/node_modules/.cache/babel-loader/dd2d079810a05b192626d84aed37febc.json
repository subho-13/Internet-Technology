{"ast":null,"code":"/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\nvar events = require('events'),\n    util = require('util'),\n    EventEmitter = events.EventEmitter;\n/**\n * Hixie Sender implementation\n */\n\n\nfunction Sender(socket) {\n  if (this instanceof Sender === false) {\n    throw new TypeError(\"Classes can't be function-called\");\n  }\n\n  events.EventEmitter.call(this);\n  this.socket = socket;\n  this.continuationFrame = false;\n  this.isClosed = false;\n}\n\nmodule.exports = Sender;\n/**\n * Inherits from EventEmitter.\n */\n\nutil.inherits(Sender, events.EventEmitter);\n/**\n * Frames and writes data.\n *\n * @api public\n */\n\nSender.prototype.send = function (data, options, cb) {\n  if (this.isClosed) return;\n  var isString = typeof data == 'string',\n      length = isString ? Buffer.byteLength(data) : data.length,\n      lengthbytes = length > 127 ? 2 : 1 // assume less than 2**14 bytes\n  ,\n      writeStartMarker = this.continuationFrame == false,\n      writeEndMarker = !options || !(typeof options.fin != 'undefined' && !options.fin),\n      buffer = new Buffer((writeStartMarker ? options && options.binary ? 1 + lengthbytes : 1 : 0) + length + (writeEndMarker && !(options && options.binary) ? 1 : 0)),\n      offset = writeStartMarker ? 1 : 0;\n\n  if (writeStartMarker) {\n    if (options && options.binary) {\n      buffer.write('\\x80', 'binary'); // assume length less than 2**14 bytes\n\n      if (lengthbytes > 1) buffer.write(String.fromCharCode(128 + length / 128), offset++, 'binary');\n      buffer.write(String.fromCharCode(length & 0x7f), offset++, 'binary');\n    } else buffer.write('\\x00', 'binary');\n  }\n\n  if (isString) buffer.write(data, offset, 'utf8');else data.copy(buffer, offset, 0);\n\n  if (writeEndMarker) {\n    if (options && options.binary) {// sending binary, not writing end marker\n    } else buffer.write('\\xff', offset + length, 'binary');\n\n    this.continuationFrame = false;\n  } else this.continuationFrame = true;\n\n  try {\n    this.socket.write(buffer, 'binary', cb);\n  } catch (e) {\n    this.error(e.toString());\n  }\n};\n/**\n * Sends a close instruction to the remote party.\n *\n * @api public\n */\n\n\nSender.prototype.close = function (code, data, mask, cb) {\n  if (this.isClosed) return;\n  this.isClosed = true;\n\n  try {\n    if (this.continuationFrame) this.socket.write(new Buffer([0xff], 'binary'));\n    this.socket.write(new Buffer([0xff, 0x00]), 'binary', cb);\n  } catch (e) {\n    this.error(e.toString());\n  }\n};\n/**\n * Sends a ping message to the remote party. Not available for hixie.\n *\n * @api public\n */\n\n\nSender.prototype.ping = function (data, options) {};\n/**\n * Sends a pong message to the remote party. Not available for hixie.\n *\n * @api public\n */\n\n\nSender.prototype.pong = function (data, options) {};\n/**\n * Handles an error\n *\n * @api private\n */\n\n\nSender.prototype.error = function (reason) {\n  this.emit('error', reason);\n  return this;\n};","map":{"version":3,"sources":["/home/subho/Programming/Internet-Technology/Athena/node_modules/ws/lib/Sender.hixie.js"],"names":["events","require","util","EventEmitter","Sender","socket","TypeError","call","continuationFrame","isClosed","module","exports","inherits","prototype","send","data","options","cb","isString","length","Buffer","byteLength","lengthbytes","writeStartMarker","writeEndMarker","fin","buffer","binary","offset","write","String","fromCharCode","copy","e","error","toString","close","code","mask","ping","pong","reason","emit"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAApB;AAAA,IACIC,IAAI,GAAGD,OAAO,CAAC,MAAD,CADlB;AAAA,IAEIE,YAAY,GAAGH,MAAM,CAACG,YAF1B;AAIA;AACA;AACA;;;AAEA,SAASC,MAAT,CAAgBC,MAAhB,EAAwB;AACtB,MAAI,gBAAgBD,MAAhB,KAA2B,KAA/B,EAAsC;AACpC,UAAM,IAAIE,SAAJ,CAAc,kCAAd,CAAN;AACD;;AAEDN,EAAAA,MAAM,CAACG,YAAP,CAAoBI,IAApB,CAAyB,IAAzB;AAEA,OAAKF,MAAL,GAAcA,MAAd;AACA,OAAKG,iBAAL,GAAyB,KAAzB;AACA,OAAKC,QAAL,GAAgB,KAAhB;AACD;;AAEDC,MAAM,CAACC,OAAP,GAAiBP,MAAjB;AAEA;AACA;AACA;;AAEAF,IAAI,CAACU,QAAL,CAAcR,MAAd,EAAsBJ,MAAM,CAACG,YAA7B;AAEA;AACA;AACA;AACA;AACA;;AAEAC,MAAM,CAACS,SAAP,CAAiBC,IAAjB,GAAwB,UAASC,IAAT,EAAeC,OAAf,EAAwBC,EAAxB,EAA4B;AAClD,MAAI,KAAKR,QAAT,EAAmB;AAEnB,MAAIS,QAAQ,GAAG,OAAOH,IAAP,IAAe,QAA9B;AAAA,MACII,MAAM,GAAGD,QAAQ,GAAGE,MAAM,CAACC,UAAP,CAAkBN,IAAlB,CAAH,GAA6BA,IAAI,CAACI,MADvD;AAAA,MAEIG,WAAW,GAAIH,MAAM,GAAG,GAAV,GAAiB,CAAjB,GAAqB,CAFvC,CAEyC;AAFzC;AAAA,MAGII,gBAAgB,GAAG,KAAKf,iBAAL,IAA0B,KAHjD;AAAA,MAIIgB,cAAc,GAAG,CAACR,OAAD,IAAY,EAAE,OAAOA,OAAO,CAACS,GAAf,IAAsB,WAAtB,IAAqC,CAACT,OAAO,CAACS,GAAhD,CAJjC;AAAA,MAKIC,MAAM,GAAG,IAAIN,MAAJ,CAAW,CAACG,gBAAgB,GAAKP,OAAO,IAAIA,OAAO,CAACW,MAApB,GAA+B,IAAIL,WAAnC,GAAkD,CAAtD,GAA2D,CAA5E,IAAiFH,MAAjF,IAA4FK,cAAc,IAAI,EAAER,OAAO,IAAIA,OAAO,CAACW,MAArB,CAAnB,GAAmD,CAAnD,GAAuD,CAAlJ,CAAX,CALb;AAAA,MAMIC,MAAM,GAAGL,gBAAgB,GAAG,CAAH,GAAO,CANpC;;AAQA,MAAIA,gBAAJ,EAAsB;AACpB,QAAIP,OAAO,IAAIA,OAAO,CAACW,MAAvB,EAA+B;AAC7BD,MAAAA,MAAM,CAACG,KAAP,CAAa,MAAb,EAAqB,QAArB,EAD6B,CAE7B;;AACA,UAAIP,WAAW,GAAG,CAAlB,EACEI,MAAM,CAACG,KAAP,CAAaC,MAAM,CAACC,YAAP,CAAoB,MAAIZ,MAAM,GAAC,GAA/B,CAAb,EAAkDS,MAAM,EAAxD,EAA4D,QAA5D;AACFF,MAAAA,MAAM,CAACG,KAAP,CAAaC,MAAM,CAACC,YAAP,CAAoBZ,MAAM,GAAC,IAA3B,CAAb,EAA+CS,MAAM,EAArD,EAAyD,QAAzD;AACD,KAND,MAOEF,MAAM,CAACG,KAAP,CAAa,MAAb,EAAqB,QAArB;AACH;;AAED,MAAIX,QAAJ,EAAcQ,MAAM,CAACG,KAAP,CAAad,IAAb,EAAmBa,MAAnB,EAA2B,MAA3B,EAAd,KACKb,IAAI,CAACiB,IAAL,CAAUN,MAAV,EAAkBE,MAAlB,EAA0B,CAA1B;;AAEL,MAAIJ,cAAJ,EAAoB;AAClB,QAAIR,OAAO,IAAIA,OAAO,CAACW,MAAvB,EAA+B,CAC7B;AACD,KAFD,MAGED,MAAM,CAACG,KAAP,CAAa,MAAb,EAAqBD,MAAM,GAAGT,MAA9B,EAAsC,QAAtC;;AACF,SAAKX,iBAAL,GAAyB,KAAzB;AACD,GAND,MAOK,KAAKA,iBAAL,GAAyB,IAAzB;;AAEL,MAAI;AACF,SAAKH,MAAL,CAAYwB,KAAZ,CAAkBH,MAAlB,EAA0B,QAA1B,EAAoCT,EAApC;AACD,GAFD,CAEE,OAAOgB,CAAP,EAAU;AACV,SAAKC,KAAL,CAAWD,CAAC,CAACE,QAAF,EAAX;AACD;AACF,CAvCD;AAyCA;AACA;AACA;AACA;AACA;;;AAEA/B,MAAM,CAACS,SAAP,CAAiBuB,KAAjB,GAAyB,UAASC,IAAT,EAAetB,IAAf,EAAqBuB,IAArB,EAA2BrB,EAA3B,EAA+B;AACtD,MAAI,KAAKR,QAAT,EAAmB;AACnB,OAAKA,QAAL,GAAgB,IAAhB;;AACA,MAAI;AACF,QAAI,KAAKD,iBAAT,EAA4B,KAAKH,MAAL,CAAYwB,KAAZ,CAAkB,IAAIT,MAAJ,CAAW,CAAC,IAAD,CAAX,EAAmB,QAAnB,CAAlB;AAC5B,SAAKf,MAAL,CAAYwB,KAAZ,CAAkB,IAAIT,MAAJ,CAAW,CAAC,IAAD,EAAO,IAAP,CAAX,CAAlB,EAA4C,QAA5C,EAAsDH,EAAtD;AACD,GAHD,CAGE,OAAOgB,CAAP,EAAU;AACV,SAAKC,KAAL,CAAWD,CAAC,CAACE,QAAF,EAAX;AACD;AACF,CATD;AAWA;AACA;AACA;AACA;AACA;;;AAEA/B,MAAM,CAACS,SAAP,CAAiB0B,IAAjB,GAAwB,UAASxB,IAAT,EAAeC,OAAf,EAAwB,CAAE,CAAlD;AAEA;AACA;AACA;AACA;AACA;;;AAEAZ,MAAM,CAACS,SAAP,CAAiB2B,IAAjB,GAAwB,UAASzB,IAAT,EAAeC,OAAf,EAAwB,CAAE,CAAlD;AAEA;AACA;AACA;AACA;AACA;;;AAEAZ,MAAM,CAACS,SAAP,CAAiBqB,KAAjB,GAAyB,UAAUO,MAAV,EAAkB;AACzC,OAAKC,IAAL,CAAU,OAAV,EAAmBD,MAAnB;AACA,SAAO,IAAP;AACD,CAHD","sourcesContent":["/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nvar events = require('events')\n  , util = require('util')\n  , EventEmitter = events.EventEmitter;\n\n/**\n * Hixie Sender implementation\n */\n\nfunction Sender(socket) {\n  if (this instanceof Sender === false) {\n    throw new TypeError(\"Classes can't be function-called\");\n  }\n\n  events.EventEmitter.call(this);\n\n  this.socket = socket;\n  this.continuationFrame = false;\n  this.isClosed = false;\n}\n\nmodule.exports = Sender;\n\n/**\n * Inherits from EventEmitter.\n */\n\nutil.inherits(Sender, events.EventEmitter);\n\n/**\n * Frames and writes data.\n *\n * @api public\n */\n\nSender.prototype.send = function(data, options, cb) {\n  if (this.isClosed) return;\n\n  var isString = typeof data == 'string'\n    , length = isString ? Buffer.byteLength(data) : data.length\n    , lengthbytes = (length > 127) ? 2 : 1 // assume less than 2**14 bytes\n    , writeStartMarker = this.continuationFrame == false\n    , writeEndMarker = !options || !(typeof options.fin != 'undefined' && !options.fin)\n    , buffer = new Buffer((writeStartMarker ? ((options && options.binary) ? (1 + lengthbytes) : 1) : 0) + length + ((writeEndMarker && !(options && options.binary)) ? 1 : 0))\n    , offset = writeStartMarker ? 1 : 0;\n\n  if (writeStartMarker) {\n    if (options && options.binary) {\n      buffer.write('\\x80', 'binary');\n      // assume length less than 2**14 bytes\n      if (lengthbytes > 1)\n        buffer.write(String.fromCharCode(128+length/128), offset++, 'binary');\n      buffer.write(String.fromCharCode(length&0x7f), offset++, 'binary');\n    } else\n      buffer.write('\\x00', 'binary');\n  }\n\n  if (isString) buffer.write(data, offset, 'utf8');\n  else data.copy(buffer, offset, 0);\n\n  if (writeEndMarker) {\n    if (options && options.binary) {\n      // sending binary, not writing end marker\n    } else\n      buffer.write('\\xff', offset + length, 'binary');\n    this.continuationFrame = false;\n  }\n  else this.continuationFrame = true;\n\n  try {\n    this.socket.write(buffer, 'binary', cb);\n  } catch (e) {\n    this.error(e.toString());\n  }\n};\n\n/**\n * Sends a close instruction to the remote party.\n *\n * @api public\n */\n\nSender.prototype.close = function(code, data, mask, cb) {\n  if (this.isClosed) return;\n  this.isClosed = true;\n  try {\n    if (this.continuationFrame) this.socket.write(new Buffer([0xff], 'binary'));\n    this.socket.write(new Buffer([0xff, 0x00]), 'binary', cb);\n  } catch (e) {\n    this.error(e.toString());\n  }\n};\n\n/**\n * Sends a ping message to the remote party. Not available for hixie.\n *\n * @api public\n */\n\nSender.prototype.ping = function(data, options) {};\n\n/**\n * Sends a pong message to the remote party. Not available for hixie.\n *\n * @api public\n */\n\nSender.prototype.pong = function(data, options) {};\n\n/**\n * Handles an error\n *\n * @api private\n */\n\nSender.prototype.error = function (reason) {\n  this.emit('error', reason);\n  return this;\n};\n"]},"metadata":{},"sourceType":"script"}