{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar EventEmitter = require('events').EventEmitter;\n\nvar util = require('util');\n\nvar debug = require('debug')('engine:socket');\n/**\n * Module exports.\n */\n\n\nmodule.exports = Socket;\n/**\n * Client class (abstract).\n *\n * @api private\n */\n\nfunction Socket(id, server, transport, req) {\n  this.id = id;\n  this.server = server;\n  this.upgrading = false;\n  this.upgraded = false;\n  this.readyState = 'opening';\n  this.writeBuffer = [];\n  this.packetsFn = [];\n  this.sentCallbackFn = [];\n  this.cleanupFn = [];\n  this.request = req; // Cache IP since it might not be in the req later\n\n  this.remoteAddress = req.connection.remoteAddress;\n  this.checkIntervalTimer = null;\n  this.upgradeTimeoutTimer = null;\n  this.pingTimeoutTimer = null;\n  this.setTransport(transport);\n  this.onOpen();\n}\n/**\n * Inherits from EventEmitter.\n */\n\n\nutil.inherits(Socket, EventEmitter);\n/**\n * Called upon transport considered open.\n *\n * @api private\n */\n\nSocket.prototype.onOpen = function () {\n  this.readyState = 'open'; // sends an `open` packet\n\n  this.transport.sid = this.id;\n  this.sendPacket('open', JSON.stringify({\n    sid: this.id,\n    upgrades: this.getAvailableUpgrades(),\n    pingInterval: this.server.pingInterval,\n    pingTimeout: this.server.pingTimeout\n  }));\n  this.emit('open');\n  this.setPingTimeout();\n};\n/**\n * Called upon transport packet.\n *\n * @param {Object} packet\n * @api private\n */\n\n\nSocket.prototype.onPacket = function (packet) {\n  if ('open' === this.readyState) {\n    // export packet event\n    debug('packet');\n    this.emit('packet', packet); // Reset ping timeout on any packet, incoming data is a good sign of\n    // other side's liveness\n\n    this.setPingTimeout();\n\n    switch (packet.type) {\n      case 'ping':\n        debug('got ping');\n        this.sendPacket('pong');\n        this.emit('heartbeat');\n        break;\n\n      case 'error':\n        this.onClose('parse error');\n        break;\n\n      case 'message':\n        this.emit('data', packet.data);\n        this.emit('message', packet.data);\n        break;\n    }\n  } else {\n    debug('packet received with closed socket');\n  }\n};\n/**\n * Called upon transport error.\n *\n * @param {Error} error object\n * @api private\n */\n\n\nSocket.prototype.onError = function (err) {\n  debug('transport error');\n  this.onClose('transport error', err);\n};\n/**\n * Sets and resets ping timeout timer based on client pings.\n *\n * @api private\n */\n\n\nSocket.prototype.setPingTimeout = function () {\n  var self = this;\n  clearTimeout(self.pingTimeoutTimer);\n  self.pingTimeoutTimer = setTimeout(function () {\n    self.onClose('ping timeout');\n  }, self.server.pingInterval + self.server.pingTimeout);\n};\n/**\n * Attaches handlers for the given transport.\n *\n * @param {Transport} transport\n * @api private\n */\n\n\nSocket.prototype.setTransport = function (transport) {\n  var onError = this.onError.bind(this);\n  var onPacket = this.onPacket.bind(this);\n  var flush = this.flush.bind(this);\n  var onClose = this.onClose.bind(this, 'transport close');\n  this.transport = transport;\n  this.transport.once('error', onError);\n  this.transport.on('packet', onPacket);\n  this.transport.on('drain', flush);\n  this.transport.once('close', onClose); // this function will manage packet events (also message callbacks)\n\n  this.setupSendCallback();\n  this.cleanupFn.push(function () {\n    transport.removeListener('error', onError);\n    transport.removeListener('packet', onPacket);\n    transport.removeListener('drain', flush);\n    transport.removeListener('close', onClose);\n  });\n};\n/**\n * Upgrades socket to the given transport\n *\n * @param {Transport} transport\n * @api private\n */\n\n\nSocket.prototype.maybeUpgrade = function (transport) {\n  debug('might upgrade socket transport from \"%s\" to \"%s\"', this.transport.name, transport.name);\n  this.upgrading = true;\n  var self = this; // set transport upgrade timer\n\n  self.upgradeTimeoutTimer = setTimeout(function () {\n    debug('client did not complete upgrade - closing transport');\n    cleanup();\n\n    if ('open' === transport.readyState) {\n      transport.close();\n    }\n  }, this.server.upgradeTimeout);\n\n  function onPacket(packet) {\n    if ('ping' === packet.type && 'probe' === packet.data) {\n      transport.send([{\n        type: 'pong',\n        data: 'probe'\n      }]);\n      self.emit('upgrading', transport);\n      clearInterval(self.checkIntervalTimer);\n      self.checkIntervalTimer = setInterval(check, 100);\n    } else if ('upgrade' === packet.type && self.readyState !== 'closed') {\n      debug('got upgrade packet - upgrading');\n      cleanup();\n      self.transport.discard();\n      self.upgraded = true;\n      self.clearTransport();\n      self.setTransport(transport);\n      self.emit('upgrade', transport);\n      self.setPingTimeout();\n      self.flush();\n\n      if (self.readyState === 'closing') {\n        transport.close(function () {\n          self.onClose('forced close');\n        });\n      }\n    } else {\n      cleanup();\n      transport.close();\n    }\n  } // we force a polling cycle to ensure a fast upgrade\n\n\n  function check() {\n    if ('polling' === self.transport.name && self.transport.writable) {\n      debug('writing a noop packet to polling for fast upgrade');\n      self.transport.send([{\n        type: 'noop'\n      }]);\n    }\n  }\n\n  function cleanup() {\n    self.upgrading = false;\n    clearInterval(self.checkIntervalTimer);\n    self.checkIntervalTimer = null;\n    clearTimeout(self.upgradeTimeoutTimer);\n    self.upgradeTimeoutTimer = null;\n    transport.removeListener('packet', onPacket);\n    transport.removeListener('close', onTransportClose);\n    transport.removeListener('error', onError);\n    self.removeListener('close', onClose);\n  }\n\n  function onError(err) {\n    debug('client did not complete upgrade - %s', err);\n    cleanup();\n    transport.close();\n    transport = null;\n  }\n\n  function onTransportClose() {\n    onError('transport closed');\n  }\n\n  function onClose() {\n    onError('socket closed');\n  }\n\n  transport.on('packet', onPacket);\n  transport.once('close', onTransportClose);\n  transport.once('error', onError);\n  self.once('close', onClose);\n};\n/**\n * Clears listeners and timers associated with current transport.\n *\n * @api private\n */\n\n\nSocket.prototype.clearTransport = function () {\n  var cleanup;\n  var toCleanUp = this.cleanupFn.length;\n\n  for (var i = 0; i < toCleanUp; i++) {\n    cleanup = this.cleanupFn.shift();\n    cleanup();\n  } // silence further transport errors and prevent uncaught exceptions\n\n\n  this.transport.on('error', function () {\n    debug('error triggered by discarded transport');\n  }); // ensure transport won't stay open\n\n  this.transport.close();\n  clearTimeout(this.pingTimeoutTimer);\n};\n/**\n * Called upon transport considered closed.\n * Possible reasons: `ping timeout`, `client error`, `parse error`,\n * `transport error`, `server close`, `transport close`\n */\n\n\nSocket.prototype.onClose = function (reason, description) {\n  if ('closed' !== this.readyState) {\n    this.readyState = 'closed';\n    clearTimeout(this.pingTimeoutTimer);\n    clearInterval(this.checkIntervalTimer);\n    this.checkIntervalTimer = null;\n    clearTimeout(this.upgradeTimeoutTimer);\n    var self = this; // clean writeBuffer in next tick, so developers can still\n    // grab the writeBuffer on 'close' event\n\n    process.nextTick(function () {\n      self.writeBuffer = [];\n    });\n    this.packetsFn = [];\n    this.sentCallbackFn = [];\n    this.clearTransport();\n    this.emit('close', reason, description);\n  }\n};\n/**\n * Setup and manage send callback\n *\n * @api private\n */\n\n\nSocket.prototype.setupSendCallback = function () {\n  var self = this;\n  this.transport.on('drain', onDrain);\n  this.cleanupFn.push(function () {\n    self.transport.removeListener('drain', onDrain);\n  }); // the message was sent successfully, execute the callback\n\n  function onDrain() {\n    if (self.sentCallbackFn.length > 0) {\n      var seqFn = self.sentCallbackFn.splice(0, 1)[0];\n\n      if ('function' === typeof seqFn) {\n        debug('executing send callback');\n        seqFn(self.transport);\n      } else if (Array.isArray(seqFn)) {\n        debug('executing batch send callback');\n\n        for (var l = seqFn.length, i = 0; i < l; i++) {\n          if ('function' === typeof seqFn[i]) {\n            seqFn[i](self.transport);\n          }\n        }\n      }\n    }\n  }\n};\n/**\n * Sends a message packet.\n *\n * @param {String} message\n * @param {Object} options\n * @param {Function} callback\n * @return {Socket} for chaining\n * @api public\n */\n\n\nSocket.prototype.send = Socket.prototype.write = function (data, options, callback) {\n  this.sendPacket('message', data, options, callback);\n  return this;\n};\n/**\n * Sends a packet.\n *\n * @param {String} packet type\n * @param {String} optional, data\n * @param {Object} options\n * @api private\n */\n\n\nSocket.prototype.sendPacket = function (type, data, options, callback) {\n  if ('function' === typeof options) {\n    callback = options;\n    options = null;\n  }\n\n  options = options || {};\n  options.compress = false !== options.compress;\n\n  if ('closing' !== this.readyState) {\n    debug('sending packet \"%s\" (%s)', type, data);\n    var packet = {\n      type: type,\n      options: options\n    };\n    if (data) packet.data = data; // exports packetCreate event\n\n    this.emit('packetCreate', packet);\n    this.writeBuffer.push(packet); // add send callback to object, if defined\n\n    if (callback) this.packetsFn.push(callback);\n    this.flush();\n  }\n};\n/**\n * Attempts to flush the packets buffer.\n *\n * @api private\n */\n\n\nSocket.prototype.flush = function () {\n  if ('closed' !== this.readyState && this.transport.writable && this.writeBuffer.length) {\n    debug('flushing buffer to transport');\n    this.emit('flush', this.writeBuffer);\n    this.server.emit('flush', this, this.writeBuffer);\n    var wbuf = this.writeBuffer;\n    this.writeBuffer = [];\n\n    if (!this.transport.supportsFraming) {\n      this.sentCallbackFn.push(this.packetsFn);\n    } else {\n      this.sentCallbackFn.push.apply(this.sentCallbackFn, this.packetsFn);\n    }\n\n    this.packetsFn = [];\n    this.transport.send(wbuf);\n    this.emit('drain');\n    this.server.emit('drain', this);\n  }\n};\n/**\n * Get available upgrades for this socket.\n *\n * @api private\n */\n\n\nSocket.prototype.getAvailableUpgrades = function () {\n  var availableUpgrades = [];\n  var allUpgrades = this.server.upgrades(this.transport.name);\n\n  for (var i = 0, l = allUpgrades.length; i < l; ++i) {\n    var upg = allUpgrades[i];\n\n    if (this.server.transports.indexOf(upg) !== -1) {\n      availableUpgrades.push(upg);\n    }\n  }\n\n  return availableUpgrades;\n};\n/**\n * Closes the socket and underlying transport.\n *\n * @param {Boolean} optional, discard\n * @return {Socket} for chaining\n * @api public\n */\n\n\nSocket.prototype.close = function (discard) {\n  if ('open' !== this.readyState) return;\n  this.readyState = 'closing';\n\n  if (this.writeBuffer.length) {\n    this.once('drain', this.closeTransport.bind(this, discard));\n    return;\n  }\n\n  this.closeTransport(discard);\n};\n/**\n * Closes the underlying transport.\n *\n * @param {Boolean} discard\n * @api private\n */\n\n\nSocket.prototype.closeTransport = function (discard) {\n  if (discard) this.transport.discard();\n  this.transport.close(this.onClose.bind(this, 'forced close'));\n};","map":{"version":3,"sources":["/home/subho/Programming/Internet-Technology/Athena/node_modules/engine.io/lib/socket.js"],"names":["EventEmitter","require","util","debug","module","exports","Socket","id","server","transport","req","upgrading","upgraded","readyState","writeBuffer","packetsFn","sentCallbackFn","cleanupFn","request","remoteAddress","connection","checkIntervalTimer","upgradeTimeoutTimer","pingTimeoutTimer","setTransport","onOpen","inherits","prototype","sid","sendPacket","JSON","stringify","upgrades","getAvailableUpgrades","pingInterval","pingTimeout","emit","setPingTimeout","onPacket","packet","type","onClose","data","onError","err","self","clearTimeout","setTimeout","bind","flush","once","on","setupSendCallback","push","removeListener","maybeUpgrade","name","cleanup","close","upgradeTimeout","send","clearInterval","setInterval","check","discard","clearTransport","writable","onTransportClose","toCleanUp","length","i","shift","reason","description","process","nextTick","onDrain","seqFn","splice","Array","isArray","l","write","options","callback","compress","wbuf","supportsFraming","apply","availableUpgrades","allUpgrades","upg","transports","indexOf","closeTransport"],"mappings":"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","sourcesContent":["/**\n * Module dependencies.\n */\n\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\nvar debug = require('debug')('engine:socket');\n\n/**\n * Module exports.\n */\n\nmodule.exports = Socket;\n\n/**\n * Client class (abstract).\n *\n * @api private\n */\n\nfunction Socket (id, server, transport, req) {\n  this.id = id;\n  this.server = server;\n  this.upgrading = false;\n  this.upgraded = false;\n  this.readyState = 'opening';\n  this.writeBuffer = [];\n  this.packetsFn = [];\n  this.sentCallbackFn = [];\n  this.cleanupFn = [];\n  this.request = req;\n\n  // Cache IP since it might not be in the req later\n  this.remoteAddress = req.connection.remoteAddress;\n\n  this.checkIntervalTimer = null;\n  this.upgradeTimeoutTimer = null;\n  this.pingTimeoutTimer = null;\n\n  this.setTransport(transport);\n  this.onOpen();\n}\n\n/**\n * Inherits from EventEmitter.\n */\n\nutil.inherits(Socket, EventEmitter);\n\n/**\n * Called upon transport considered open.\n *\n * @api private\n */\n\nSocket.prototype.onOpen = function () {\n  this.readyState = 'open';\n\n  // sends an `open` packet\n  this.transport.sid = this.id;\n  this.sendPacket('open', JSON.stringify({\n    sid: this.id,\n    upgrades: this.getAvailableUpgrades(),\n    pingInterval: this.server.pingInterval,\n    pingTimeout: this.server.pingTimeout\n  }));\n\n  this.emit('open');\n  this.setPingTimeout();\n};\n\n/**\n * Called upon transport packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onPacket = function (packet) {\n  if ('open' === this.readyState) {\n    // export packet event\n    debug('packet');\n    this.emit('packet', packet);\n\n    // Reset ping timeout on any packet, incoming data is a good sign of\n    // other side's liveness\n    this.setPingTimeout();\n\n    switch (packet.type) {\n\n      case 'ping':\n        debug('got ping');\n        this.sendPacket('pong');\n        this.emit('heartbeat');\n        break;\n\n      case 'error':\n        this.onClose('parse error');\n        break;\n\n      case 'message':\n        this.emit('data', packet.data);\n        this.emit('message', packet.data);\n        break;\n    }\n  } else {\n    debug('packet received with closed socket');\n  }\n};\n\n/**\n * Called upon transport error.\n *\n * @param {Error} error object\n * @api private\n */\n\nSocket.prototype.onError = function (err) {\n  debug('transport error');\n  this.onClose('transport error', err);\n};\n\n/**\n * Sets and resets ping timeout timer based on client pings.\n *\n * @api private\n */\n\nSocket.prototype.setPingTimeout = function () {\n  var self = this;\n  clearTimeout(self.pingTimeoutTimer);\n  self.pingTimeoutTimer = setTimeout(function () {\n    self.onClose('ping timeout');\n  }, self.server.pingInterval + self.server.pingTimeout);\n};\n\n/**\n * Attaches handlers for the given transport.\n *\n * @param {Transport} transport\n * @api private\n */\n\nSocket.prototype.setTransport = function (transport) {\n  var onError = this.onError.bind(this);\n  var onPacket = this.onPacket.bind(this);\n  var flush = this.flush.bind(this);\n  var onClose = this.onClose.bind(this, 'transport close');\n\n  this.transport = transport;\n  this.transport.once('error', onError);\n  this.transport.on('packet', onPacket);\n  this.transport.on('drain', flush);\n  this.transport.once('close', onClose);\n  // this function will manage packet events (also message callbacks)\n  this.setupSendCallback();\n\n  this.cleanupFn.push(function () {\n    transport.removeListener('error', onError);\n    transport.removeListener('packet', onPacket);\n    transport.removeListener('drain', flush);\n    transport.removeListener('close', onClose);\n  });\n};\n\n/**\n * Upgrades socket to the given transport\n *\n * @param {Transport} transport\n * @api private\n */\n\nSocket.prototype.maybeUpgrade = function (transport) {\n  debug('might upgrade socket transport from \"%s\" to \"%s\"'\n    , this.transport.name, transport.name);\n\n  this.upgrading = true;\n\n  var self = this;\n\n  // set transport upgrade timer\n  self.upgradeTimeoutTimer = setTimeout(function () {\n    debug('client did not complete upgrade - closing transport');\n    cleanup();\n    if ('open' === transport.readyState) {\n      transport.close();\n    }\n  }, this.server.upgradeTimeout);\n\n  function onPacket (packet) {\n    if ('ping' === packet.type && 'probe' === packet.data) {\n      transport.send([{ type: 'pong', data: 'probe' }]);\n      self.emit('upgrading', transport);\n      clearInterval(self.checkIntervalTimer);\n      self.checkIntervalTimer = setInterval(check, 100);\n    } else if ('upgrade' === packet.type && self.readyState !== 'closed') {\n      debug('got upgrade packet - upgrading');\n      cleanup();\n      self.transport.discard();\n      self.upgraded = true;\n      self.clearTransport();\n      self.setTransport(transport);\n      self.emit('upgrade', transport);\n      self.setPingTimeout();\n      self.flush();\n      if (self.readyState === 'closing') {\n        transport.close(function () {\n          self.onClose('forced close');\n        });\n      }\n    } else {\n      cleanup();\n      transport.close();\n    }\n  }\n\n  // we force a polling cycle to ensure a fast upgrade\n  function check () {\n    if ('polling' === self.transport.name && self.transport.writable) {\n      debug('writing a noop packet to polling for fast upgrade');\n      self.transport.send([{ type: 'noop' }]);\n    }\n  }\n\n  function cleanup () {\n    self.upgrading = false;\n\n    clearInterval(self.checkIntervalTimer);\n    self.checkIntervalTimer = null;\n\n    clearTimeout(self.upgradeTimeoutTimer);\n    self.upgradeTimeoutTimer = null;\n\n    transport.removeListener('packet', onPacket);\n    transport.removeListener('close', onTransportClose);\n    transport.removeListener('error', onError);\n    self.removeListener('close', onClose);\n  }\n\n  function onError (err) {\n    debug('client did not complete upgrade - %s', err);\n    cleanup();\n    transport.close();\n    transport = null;\n  }\n\n  function onTransportClose () {\n    onError('transport closed');\n  }\n\n  function onClose () {\n    onError('socket closed');\n  }\n\n  transport.on('packet', onPacket);\n  transport.once('close', onTransportClose);\n  transport.once('error', onError);\n\n  self.once('close', onClose);\n};\n\n/**\n * Clears listeners and timers associated with current transport.\n *\n * @api private\n */\n\nSocket.prototype.clearTransport = function () {\n  var cleanup;\n\n  var toCleanUp = this.cleanupFn.length;\n\n  for (var i = 0; i < toCleanUp; i++) {\n    cleanup = this.cleanupFn.shift();\n    cleanup();\n  }\n\n  // silence further transport errors and prevent uncaught exceptions\n  this.transport.on('error', function () {\n    debug('error triggered by discarded transport');\n  });\n\n  // ensure transport won't stay open\n  this.transport.close();\n\n  clearTimeout(this.pingTimeoutTimer);\n};\n\n/**\n * Called upon transport considered closed.\n * Possible reasons: `ping timeout`, `client error`, `parse error`,\n * `transport error`, `server close`, `transport close`\n */\n\nSocket.prototype.onClose = function (reason, description) {\n  if ('closed' !== this.readyState) {\n    this.readyState = 'closed';\n    clearTimeout(this.pingTimeoutTimer);\n    clearInterval(this.checkIntervalTimer);\n    this.checkIntervalTimer = null;\n    clearTimeout(this.upgradeTimeoutTimer);\n    var self = this;\n    // clean writeBuffer in next tick, so developers can still\n    // grab the writeBuffer on 'close' event\n    process.nextTick(function () {\n      self.writeBuffer = [];\n    });\n    this.packetsFn = [];\n    this.sentCallbackFn = [];\n    this.clearTransport();\n    this.emit('close', reason, description);\n  }\n};\n\n/**\n * Setup and manage send callback\n *\n * @api private\n */\n\nSocket.prototype.setupSendCallback = function () {\n  var self = this;\n  this.transport.on('drain', onDrain);\n\n  this.cleanupFn.push(function () {\n    self.transport.removeListener('drain', onDrain);\n  });\n\n  // the message was sent successfully, execute the callback\n  function onDrain () {\n    if (self.sentCallbackFn.length > 0) {\n      var seqFn = self.sentCallbackFn.splice(0, 1)[0];\n      if ('function' === typeof seqFn) {\n        debug('executing send callback');\n        seqFn(self.transport);\n      } else if (Array.isArray(seqFn)) {\n        debug('executing batch send callback');\n        for (var l = seqFn.length, i = 0; i < l; i++) {\n          if ('function' === typeof seqFn[i]) {\n            seqFn[i](self.transport);\n          }\n        }\n      }\n    }\n  }\n};\n\n/**\n * Sends a message packet.\n *\n * @param {String} message\n * @param {Object} options\n * @param {Function} callback\n * @return {Socket} for chaining\n * @api public\n */\n\nSocket.prototype.send =\nSocket.prototype.write = function (data, options, callback) {\n  this.sendPacket('message', data, options, callback);\n  return this;\n};\n\n/**\n * Sends a packet.\n *\n * @param {String} packet type\n * @param {String} optional, data\n * @param {Object} options\n * @api private\n */\n\nSocket.prototype.sendPacket = function (type, data, options, callback) {\n  if ('function' === typeof options) {\n    callback = options;\n    options = null;\n  }\n\n  options = options || {};\n  options.compress = false !== options.compress;\n\n  if ('closing' !== this.readyState) {\n    debug('sending packet \"%s\" (%s)', type, data);\n\n    var packet = {\n      type: type,\n      options: options\n    };\n    if (data) packet.data = data;\n\n    // exports packetCreate event\n    this.emit('packetCreate', packet);\n\n    this.writeBuffer.push(packet);\n\n    // add send callback to object, if defined\n    if (callback) this.packetsFn.push(callback);\n\n    this.flush();\n  }\n};\n\n/**\n * Attempts to flush the packets buffer.\n *\n * @api private\n */\n\nSocket.prototype.flush = function () {\n  if ('closed' !== this.readyState &&\n                this.transport.writable &&\n                this.writeBuffer.length) {\n    debug('flushing buffer to transport');\n    this.emit('flush', this.writeBuffer);\n    this.server.emit('flush', this, this.writeBuffer);\n    var wbuf = this.writeBuffer;\n    this.writeBuffer = [];\n    if (!this.transport.supportsFraming) {\n      this.sentCallbackFn.push(this.packetsFn);\n    } else {\n      this.sentCallbackFn.push.apply(this.sentCallbackFn, this.packetsFn);\n    }\n    this.packetsFn = [];\n    this.transport.send(wbuf);\n    this.emit('drain');\n    this.server.emit('drain', this);\n  }\n};\n\n/**\n * Get available upgrades for this socket.\n *\n * @api private\n */\n\nSocket.prototype.getAvailableUpgrades = function () {\n  var availableUpgrades = [];\n  var allUpgrades = this.server.upgrades(this.transport.name);\n  for (var i = 0, l = allUpgrades.length; i < l; ++i) {\n    var upg = allUpgrades[i];\n    if (this.server.transports.indexOf(upg) !== -1) {\n      availableUpgrades.push(upg);\n    }\n  }\n  return availableUpgrades;\n};\n\n/**\n * Closes the socket and underlying transport.\n *\n * @param {Boolean} optional, discard\n * @return {Socket} for chaining\n * @api public\n */\n\nSocket.prototype.close = function (discard) {\n  if ('open' !== this.readyState) return;\n\n  this.readyState = 'closing';\n\n  if (this.writeBuffer.length) {\n    this.once('drain', this.closeTransport.bind(this, discard));\n    return;\n  }\n\n  this.closeTransport(discard);\n};\n\n/**\n * Closes the underlying transport.\n *\n * @param {Boolean} discard\n * @api private\n */\n\nSocket.prototype.closeTransport = function (discard) {\n  if (discard) this.transport.discard();\n  this.transport.close(this.onClose.bind(this, 'forced close'));\n};\n"]},"metadata":{},"sourceType":"script"}